<!DOCTYPE html>
<html>

<head>
    <title>Radiation 3D prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
        }

        #functionbox {
            width: 250px;
            height: auto;
            max-height: calc(100vh - 60px);
            position: absolute;
            top: 50px;
            left: 10px;
            z-index: 100;

            background-color: #b5cea8;
            background-color: #4444447e;
            border-radius: 4px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        #renderbody {
            width: 100%;
            height: 100vh;
        }

        .custom-file-upload {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 22px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .custom-file-upload:hover {
            background-color: #007e7a;
        }

        .custom-file-upload:active {
            transform: scale(0.97);
        }

        #top {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 5px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 1px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #top:hover {
            background: #007e7a;
        }

        #front {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #front:hover {
            background: #007e7a;
        }

        #side {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #side:hover {
            background: #007e7a;
        }

        #perspective {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #perspective:hover {
            background: #007e7a;
        }

        #renderbody {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Add this to your existing style section */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .scale-input-modal {
            position: fixed;
            z-index: 1001;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
        }

        .scale-input-modal h3 {
            margin: 0 0 20px 0;
            font-family: 'Poppins', sans-serif;
            color: #333;
        }

        .scale-input-modal input {
            padding: 10px 15px;
            font-size: 18px;
            font-family: 'Poppins', sans-serif;
            border: 2px solid #ccc;
            border-radius: 8px;
            width: 200px;
            margin: 10px;
            outline: none;
        }

        .scale-input-modal input:focus {
            border-color: #00a19b;
        }

        .scale-input-modal button {
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            background: #00a19b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
        }

        .scale-input-modal button:hover {
            background: #007e7a;
        }
        
        .modal-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            gap: 30px;
            max-width: 90vw;
            max-height: 90vh;
        }

        #valueDisplay {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1001;
            white-space: nowrap;
        }

        .modal-content {
            display: block;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            cursor: zoom-in;
            max-width: 70vw;
            max-height: 85vh;
            object-fit: contain;
            transform: scaleY(-1);
        }

        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1003;
        }

        #scalinginput, #gridSizeInput {
            padding: 6px 8px;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            margin-left: 25px;
            width: 200px;
            max-width: 185px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        
        #gridSizeInput {
            background-color: white;
            cursor: pointer;
        }
        
        #colorScaleMin, #colorScaleMax {
            padding: 6px 8px;
            font-size: 18px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            width: 35px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            margin: 5px 5px;
        }

        #autoColorScaleBtn {
            padding: 6px 12px;
            font-size: 14px;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            background: #00a19b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 8px;
            transition: background 0.2s;
        }

        #autoColorScaleBtn:hover {
            background: #007e7a;
        }
        
        .color-scale-container {
            display: flex;
            align-items: center;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalinginput:placeholder, #gridSizeInput:placeholder, #colorScaleMin:placeholder, #colorScaleMax:placeholder {
            color: #aaa;
        }

        #scalinginput:focus, #gridSizeInput:focus, #colorScaleMin:focus, #colorScaleMax:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        #scalingbutton {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalingbutton:hover {
            background: #007e7a;
        }

        #updatescale {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #updatescale:hover {
            background: #007e7a;
        }

        #exportBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #exportBtn:hover {
            background: #007e7a;
        }


        #importbtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 24px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #importbtn:hover {
            background-color: #007e7a;
        }

        #importbtn:active {
            transform: scale(0.97);
        }

        #detail {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #detail:hover {
            background: #007e7a;
        }

        #calculate {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #calculate:hover {
            background: #007e7a;
        }

        #calculate.calculating {
            background: #e07b39;
        }
        #calculate.calculating:hover {
            background: #c46930;
        }

        #calcProgressWrap {
            margin-left: 25px;
            margin-top: 8px;
            margin-bottom: 8px;
            display: none;
            width: calc(100% - 50px);
            box-sizing: border-box;
        }
        #calcProgressWrap.visible {
            display: block;
        }
        #calcProgressBar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.25);
            border-radius: 4px;
            overflow: hidden;
        }
        #calcProgressFill {
            height: 100%;
            width: 0%;
            position: relative;
            background: linear-gradient(90deg, #0088cc, #00b4d8, #48cae4, #90e0ef);
            background-size: 300% 100%;
            border-radius: 4px;
            transition: width 0.15s ease-out;
            animation: calcProgressGradient 2s linear infinite;
            box-shadow: 0 0 12px rgba(0, 180, 216, 0.4);
        }
        #calcProgressFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255,255,255,0.4) 45%,
                rgba(255,255,255,0.6) 50%,
                rgba(255,255,255,0.4) 55%,
                transparent 100%
            );
            background-size: 40% 100%;
            animation: calcProgressShimmer 1.2s ease-in-out infinite;
        }
        @keyframes calcProgressGradient {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        @keyframes calcProgressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(350%); }
        }
        #calcProgressPct {
            font-family: 'Poppins', sans-serif;
            font-size: 12px;
            color: rgba(255,255,255,0.9);
            margin-top: 4px;
        }

        /* Distance display */
        #distanceRow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 25px;
            margin-top: 10px;
            margin-bottom: 5px;
        }

        #distanceRow span {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 16px;
            padding: 6px 12px;
            background: #00a19b;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
        }

        #distanceInput {
            padding: 6px 8px;
            font-size: 18px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            width: 80px;
            background-color: white;
            text-align: center;
        }

        /* Scene Manager Styles */
        #sceneNameInput {
            font-family: 'Poppins', sans-serif;
            font-size: large;
            padding: 8px;
            border: none;
            border-radius: 4px;
            color: black;
            background: white;
            margin-left: 25px;
            width: calc(100% - 50px);
            box-sizing: border-box;
        }

        #sceneNameInput:focus {
            outline: none;
            background: #f0f0f0;
        }

        #saveSceneBtn, #newSceneBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #saveSceneBtn:hover {
            background: #007e7a;
        }

        #newSceneBtn {
            background: #00a19b;
        }

        #newSceneBtn:hover {
            background: #007e7e;
        }

        #sceneDropdown {
            padding: 6px 8px;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            margin-left: 25px;
            width: 200px;
            max-width: 185px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            margin-top: 5px;
            margin-bottom: 5px;
            background-color: white;
            cursor: pointer;
        }

        #sceneDropdown:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        #sceneDropdown option {
            background: white;
            color: black;
        }

        .scene-buttons-container {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        #loadSceneBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 95px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 1px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #loadSceneBtn:hover {
            background: #007e7a;
            margin-left: 10px;
        }

        #deleteSceneBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 95px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 1px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #deleteSceneBtn:hover {
            background: #c9302c;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            outline: none;
        }

        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }

        p {
            font: bolder;
            font-size: 24px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            margin: 5px 0 10px 0;
            font-weight: bold;
            color: aliceblue;
        }

        #validationbtn {
            display: block;
            font: 400;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            font-weight: bold;
            color: aliceblue;
            background: #00a19c85;
            text-decoration: none;
            border-radius: 4px;
            width: 250px;

        }

        #validationbtn:hover {
            background: #007e7a;
        }

        /* Accordion/Dropdown Sections */
        .section-header {
            font: bolder;
            font-size: 22px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            margin: 0;
            padding: 12px 10px;
            font-weight: bold;
            color: aliceblue;
            background-color: rgba(0, 161, 155, 0.5);
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s ease;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-header:hover {
            background-color: rgba(0, 161, 155, 0.5);
        }

        .section-header:active {
            background-color: rgba(0, 161, 155, 0.6);
        }

        .section-header::after {
            content: '\25BC'; /* Down arrow Unicode */
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .section-header.collapsed::after {
            transform: translateY(-50%) rotate(-90deg);
        }

        .section-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 1;
            padding: 5px 0;
        }

        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }

        .my-custom-gui {
            font-size: 26px;
            width: 700px;
            background-color: #222;
            border-radius: 10px;
            padding: 20px;
        }

        /* Bigger dat.GUI with your color scheme */
        .dg.main {
            font-family: 'Poppins', sans-serif !important;
            font-size: 20px !important;
            background-color: rgba(68, 68, 68, 0.8) !important;
            border-radius: 4px !important;
            width: 500px !important;
        }

        .dg .cr {
            height: 40px !important;
            line-height: 40px !important;
            border-bottom: 1px solid #444 !important;
        }

        .dg .c input[type=text] {
            height: 28px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 100% !important;
            margin-left: 0 !important;
        }

        .dg .c select {
            height: 34px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 102% !important;
            margin-left: -7px !important;
        }

        .dg .c select option {
            border-radius: 8px;
            padding: 4px 8px;
        }
        

        .dg .c .slider {
            display: none !important;
        }

        .dg .c .slider-fg {
            background: #00a19b !important;
            height: 24px !important;
        }

        .dg .c .slider:hover .slider-fg {
            background: #007e7a !important;
        }

        .dg .title {
            font-size: 18px !important;
            padding: 8px 10px !important;
            background-color: rgba(0, 161, 155, 0.3) !important;
        }

        .dg .cr.function .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        .dg .cr.function:hover {
            background: rgba(0, 161, 155, 0.2) !important;
        }

        .dg .cr.number .property-name,
        .dg .cr.boolean .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        /* Make checkbox bigger to fit the larger GUI */
        .dg .cr.boolean input[type="checkbox"] {
            width: 20px !important;
            height: 20px !important;
        }

        .dg .cr.boolean .checkbox {
            width: 20px !important;
            height: 20px !important;
        }

        .dg.main .close-button {
            display: none !important;
        }

        .dg.main .close-button:hover {
            background-color: #007e7a !important;
        }

        .view-buttons-container {
            display: flex;
            justify-content: center;
        }

        .transform-buttons-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 0 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .plane-buttons-container {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 10px;
            padding: 0 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .transform-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: 18px;
            padding: 10px 8px;
            background: #00a19b;
            height: 45px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .transform-btn:hover {
            background: #007e7a;
        }

        .transform-btn:active {
            transform: scale(0.97);
        }

        .plane-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: 18px;
            padding: 10px 8px;
            background: #00a19b;
            height: 45px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
        }

        .plane-btn:hover {
            background: #007e7a;
        }

        .plane-btn:active {
            transform: scale(0.97);
        }

        .transform-btn.active {
            background: #006662;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .plane-btn.active {
            background: #006662;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .grid-buttons-container {
            display: flex;
            gap: 5px;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #toggleGrid, #gridSnapBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: 14px;
            padding: 8px 10px;
            background: #00a19b;
            width: 97px;
            height: 45px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #toggleGrid:hover, #gridSnapBtn:hover {
            background: #007e7a;
        }

        #gridSnapBtn.active {
            background: #006662;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #addPlaneMode {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #addPlaneMode:hover {
            background: #007e7a;
        }
        
        #addPlaneMode:disabled {
            cursor: not-allowed;
            opacity: 0.9;
        }

        #colorLegend {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-family: 'Poppins', sans-serif;
            min-width: 200px;
        }

        #colorLegend h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: center;
            color: #333;
        }
        
        #colorLegend .data-range-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 200, 0.3);
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            border: 1px solid #ccc;
        }
        
        #colorLegend .data-range-info strong {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .legend-gradient {
            width: 40px;
            height: 300px;
            border: 2px solid #333;
            border-radius: 4px;
            margin: 0 auto;
        }

        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 300px;
            margin-left: 10px;
            font-size: 14px;
            color: #333;
        }

        .legend-container {
            display: flex;
            align-items: center;
        }
    </style>

</head>

<body>

    <div id="functionbox">
        <!-- Floor plan section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Floor plan</div>
        <div class="section-content collapsed">
        <input type="file" id="imageInput" accept="image/*" hidden>
        <label for="imageInput" class="custom-file-upload">Upload Image</label>
        </div>

        <!-- Plane section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Plane</div>
        <div class="section-content collapsed">
            <div class="plane-buttons-container">
                <button id="addplane" class="plane-btn">Add</button>
                <button id="deleteplane" class="plane-btn">Delete</button>
                <button id="resetPlane" class="plane-btn">Reset</button>
                <button id="standPlane" class="plane-btn">Stand</button>
            </div>
            <button id="addPlaneMode" class="plane-btn" style="margin: 5px 25px; width: 180px" >Add Walls</button>
        </div>

        <!-- Transform Controls section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Controls</div>
        <div class="section-content collapsed">
            <div class="transform-buttons-container">
                <button id="transformQ" class="transform-btn">Local</button>
                <button id="transformW" class="transform-btn">Translate</button>
                <button id="transformE" class="transform-btn">Scale</button>
                <button id="transformR" class="transform-btn">Rotate</button>
            </div>
        </div>

        <!-- Views section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Views</div>
        <div class="section-content collapsed">
        <div class="view-buttons-container">
            <button id="top">Top</button>
            <button id="front"> Front</button>
            <button id="side">Side</button>
        </div>
        <button id="perspective">Perspective</button>
            <div class="grid-buttons-container">
                <button id="toggleGrid">Hide Grid</button>
                <button id="gridSnapBtn">Grid Snap</button>
            </div>
        </div>

        <!-- Scaling section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Scaling</div>
        <div class="section-content collapsed">
        <button id="scalingbutton"> Set Scale </button>
        </div>

        <!-- Precision section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Resolution</div>
        <div class="section-content collapsed">
            <select id="gridSizeInput" style="margin-left: 25px; margin-top: 5px; margin-bottom: 5px;">
                <option value="2" selected>Low</option>
                <option value="3">Mid</option>
                <option value="5">High</option>
                <option value="10">Detailed</option>
            </select>
        </div>

        <!-- Color Scale section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Color Scale</div>
        <div class="section-content collapsed">
        <div class="color-scale-container">
            <button id="autoColorScaleBtn">Auto</button>
            <input type="number" id="colorScaleMin" placeholder="Min" step="0.1" value="0">
            <span style="color: white; font-family: 'Poppins', sans-serif;">to</span>
            <input type="number" id="colorScaleMax" placeholder="Max" step="0.1" value="20">
        </div>
        </div>

        <!-- Save section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Save</div>
        <div class="section-content collapsed">
        <button id="exportBtn"> Export Scene</button>
        <input type="file" id="importFile" accept=".json" hidden>
        <label for="importFile" id="importbtn"> Import Scene </label>
        </div>


        <!-- Calculation section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Calculation</div>
        <div class="section-content collapsed">
        <button id="detail">Show detail</button>
        <button id="calculate">Calculate</button>
        <div id="calcProgressWrap" class="">
            <div id="calcProgressBar"><div id="calcProgressFill"></div></div>
            <div id="calcProgressPct">0%</div>
        </div>
        <div id="distanceRow">
            <span>Distance</span>
            <input type="text" id="distanceInput" readonly value="-" />
        </div>
        </div>

        <!-- Scene Manager section -->
        <div class="section-header collapsed" onclick="toggleSection(this)">Level Manager</div>
        <div class="section-content collapsed">
        <button id="saveSceneBtn">Save Level</button>
        <select id="sceneDropdown">
            <option value="">Select a level...</option>
        </select>
        <div class="scene-buttons-container">
            <button id="loadSceneBtn">Load</button>
            <button id="deleteSceneBtn">Delete</button>
        </div>
        <button id="newSceneBtn">New Level</button>
        </div>

        <a id="validationbtn" href="../validation/validation.html">Validation</a>

    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>
    <div id="renderbody"></div>
    <div id="contourModal" class="modal">
        <span class="close">&times;</span>
        <div id="valueDisplay"></div>
        <div class="modal-container">
        <img id="contourImage" class="modal-content">
            <div id="colorLegend">
                <h3>Heat Flux Scale</h3>
                <div class="legend-container">
                    <div class="legend-gradient" id="legendGradient"></div>
                    <div class="legend-labels" id="legendLabels"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scale Input Modal -->
    <div id="scaleInputModal" class="scale-input-modal" style="display: none;">
        <h3>Enter Distance</h3>
        <input type="number" id="scaleDistanceInput" placeholder="Enter distance">
        <br>
        <button id="confirmScale">Confirm</button>
    </div>

    <!-- Level Name Input Modal -->
    <div id="levelNameModal" class="scale-input-modal" style="display: none;">
        <h3>Enter Level Name</h3>
        <input type="text" id="levelNameInput" placeholder="Enter level name">
        <br>
        <button id="confirmLevelName">Save Level</button>
        <button id="cancelLevelName">Cancel</button>
    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-contour@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        // Toggle section collapse/expand
        function toggleSection(header) {
            const content = header.nextElementSibling;
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand
                content.classList.remove('collapsed');
                header.classList.remove('collapsed');
            } else {
                // Collapse
                content.classList.add('collapsed');
                header.classList.add('collapsed');
            }
        }

        // Configuration
        const CONFIG = {
            // Backend API URL - use localhost when running locally
            BACKEND_URL: 'http://localhost:8080',
            
            // API endpoints
            CALCULATE_ENDPOINT: '/calculate',
            HEALTH_ENDPOINT: '/health',
            STATUS_ENDPOINT: '/status',
            
            // Request settings
            REQUEST_TIMEOUT: 60000, // 60 seconds
            MAX_RETRIES: 3
        };
        
        console.log("Radiation 3D Application loaded with config:", CONFIG);

        // Backend communication utilities
        async function checkBackendHealth() {
            try {
                const response = await fetch(CONFIG.BACKEND_URL + CONFIG.HEALTH_ENDPOINT, {
                    method: 'GET',
                    timeout: 5000
                });
                return response.ok;
            } catch (error) {
                console.warn('Backend health check failed:', error);
                return false;
            }
        }

        async function getBackendStatus() {
            try {
                const response = await fetch(CONFIG.BACKEND_URL + CONFIG.STATUS_ENDPOINT, {
                    method: 'GET',
                    timeout: 5000
                });
                if (response.ok) {
                    return await response.json();
                }
                return null;
            } catch (error) {
                console.warn('Backend status check failed:', error);
                return null;
            }
        }

        // Test backend connection on page load
        async function testBackendConnection() {
            console.log('Testing backend connection...');
            const isHealthy = await checkBackendHealth();
            if (isHealthy) {
                console.log(' Backend is healthy');
                const status = await getBackendStatus();
                if (status) {
                    console.log('Backend status:', status);
                }
            } else {
                console.warn('Backend is not responding. Check your configuration.');
                console.log('Current backend URL:', CONFIG.BACKEND_URL);
            }
        }

        // Add these variables near the top with your other variables
        let history = [];
        let groupDragStartPosition = null;
        let historyIndex = -1;
        const MAX_HISTORY_STEPS = 500; // Prevent memory bloat
        function initializeHistory() {
            // Capture initial state with all plane properties
            const initialState = planes.map(plane => ({
                id: plane.id || generateId(),
                position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(),
                rotation: plane.mesh.rotation.clone(),
                scale: plane.mesh.scale.clone(),
                width: plane.width,
                height: plane.height,
                // Store default values
                defaultWidth: plane.defaultWidth,
                defaultHeight: plane.defaultHeight,
                defaultX: plane.defaultX,
                defaultY: plane.defaultY,
                defaultZ: plane.defaultZ,
                defaultAngle: plane.defaultAngle,
                defaultColor: plane.defaultColor,
                // Store derived properties
                x: plane.x,
                y: plane.y,
                z: plane.z,
                angle: plane.angle,
                incline: plane.incline,
                color: plane.color,
                temperature: plane.temperature,
                type: plane.type,
                name: plane.name,
                selected: false,
                // Store material properties
                hasTexture: plane.mesh.material.map !== null,
                textureData: plane.mesh.material.map ? {
                    isContourTexture: plane.mesh.material.map.isContourTexture || false,
                    contourData: plane.mesh.material.map.contourData || null
                } : null
            }));

            history = [initialState];
            historyIndex = 0;
        }



        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyIndex);
                
                // If in plane mode, also remove the last point so the next click
                // creates a plane from the correct starting point
                if (planeMode && planePoints.length > 1) {
                    planePoints.pop();
                }
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(historyIndex);
            }
        }

        function isTypingInInput() {
            const el = document.activeElement;
            if (!el) return false;
            const tag = el.tagName?.toLowerCase();
            return tag === 'input' || tag === 'textarea' || tag === 'select' || el.isContentEditable;
        }

        // Replace the current keyboard event listener with this:
        window.addEventListener('keydown', (event) => {
            if (isTypingInInput()) return;
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    undo();
                    event.preventDefault();
                } else if ((event.key === 'y' || (event.shiftKey && event.key === 'z'))) {
                    redo();
                    event.preventDefault();
                }
            }
        });

        // Add event listeners for buttons
        document.getElementById('undoBtn')?.addEventListener('click', undo);
        document.getElementById('redoBtn')?.addEventListener('click', redo);

        // Now we need to capture states at key moments. Add these calls:

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#f5f5f5"); // Gentle white background


        //set up different camera parameters
        const frustumSize = 40;
        const cameras = {
            perspective: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
            top: new THREE.OrthographicCamera(),
            front: new THREE.OrthographicCamera(),
            left: new THREE.OrthographicCamera()
        }

        cameras.perspective.position.set(10, 10, 10);
        cameras.top.position.set(0, 10, 0);
        cameras.top.lookAt(0, 0, 0);
        cameras.front.position.set(0, 0, 10);
        cameras.front.lookAt(0, 0, 0);
        cameras.left.position.set(-10, 0, 0);
        cameras.left.lookAt(0, 0, 0);

        for (const key in cameras) cameras[key].lookAt(0, 0, 0);
        let activeCamera = cameras.perspective;

        function updateOrthoCameras() {
            const aspect = window.innerWidth / window.innerHeight;
            for (const key of ['top', 'front', 'left']) {
                const cam = cameras[key];
                cam.left = frustumSize * aspect / -2; cam.right = frustumSize * aspect / 2;
                cam.top = frustumSize / 2; cam.bottom = frustumSize / -2;
                cam.near = 0.1; cam.far = 1000;
                cam.updateProjectionMatrix();
            }
        }

        updateOrthoCameras();

        document.getElementById('perspective').addEventListener('click', () => setView(cameras.perspective));
        document.getElementById('top').addEventListener('click', () => {
            setView(cameras.top)
        });
        document.getElementById('front').addEventListener('click', () => {
            setView(cameras.front)
        });
        document.getElementById('side').addEventListener('click', () => {
            setView(cameras.left)
        });

        // Toggle grid visibility
        let gridVisible = true;
        document.getElementById('toggleGrid').addEventListener('click', toggleGridVisibility);

        function toggleGridVisibility() {
            gridVisible = !gridVisible;
            grid.visible = gridVisible;
            
            // Update button text
            const toggleBtn = document.getElementById('toggleGrid');
            toggleBtn.textContent = gridVisible ? 'Hide Grid' : 'Show Grid';
            
        }

        // Grid snap button functionality
        document.getElementById('gridSnapBtn').addEventListener('click', toggleGridSnap);

        function toggleGridSnap() {
            // Toggle all grid snap settings
            gridSnapConfig.translation.enabled = !gridSnapConfig.translation.enabled;
            gridSnapConfig.rotation.enabled = !gridSnapConfig.rotation.enabled;
            gridSnapConfig.scale.enabled = !gridSnapConfig.scale.enabled;
            
            // Update button state
            updateGridSnapButtonState();
        }

        function updateGridSnapButtonState() {
            const gridSnapBtn = document.getElementById('gridSnapBtn');
            if (gridSnapConfig.translation.enabled) {
                gridSnapBtn.classList.add('active');
            } else {
                gridSnapBtn.classList.remove('active');
            }
        }

        // At the top with your other variables
        let selectedPlanes = []; // Array to store multiple selected planes
        let isShiftPressed = false; // Track shift key state
        
        // Sphere selection and dragging
        let selectedSphere = null;
        let isDraggingSphere = false;
        let dragStartPosition = new THREE.Vector3();
        let sphereOriginalColor = null;
        let orbitControlsDisabled = false;
        
        // Double-click detection for spheres
        let lastClickedSphere = null;
        let lastSphereClickTime = 0;
        const SPHERE_DOUBLE_CLICK_DELAY = 500; // 500ms window for double-click (generous for easier use)
        
        // Hover state for spheres
        let hoveredSphere = null;
        
        // Plane creation variables
        let planeMode = false;
        let planePoints = [];
        let continuousPlanes = []; // Store plane objects created as continuous planes
        let planeClickHandler = null;
        let clickTimeout = null;
        
        // Right-click panning variables for plane mode
        let isPanningInPlaneMode = false;
        let panStartPosition = { x: 0, y: 0 };
        let cameraStartPosition = { x: 0, z: 0 };
        
        // Add these near your other variables
        let selectedPlaneGroup = null; // Will store the temporary group
        let originalPositions = new Map(); // Stores original positions before grouping
        let normalArrow = null; // Arrow to visualize the normal direction
        let showNormalArrow = true; // Toggle for showing normal arrow

        // Add these near your other event listeners (like the keydown for transform controls)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = true;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = false;
            }
        });


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("renderbody").appendChild(renderer.domElement);


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Group for top-view 2D rotation (vinyl-style: scene spins, camera stays fixed)
        const sceneContentGroup = new THREE.Group();
        scene.add(sceneContentGroup);
        let topViewRotationAngle = 0;

        // Add a grid (hidden by default) with snapping-compatible size
        const gridSize = 100;
        const gridDivisions = 100;
        const grid = new THREE.GridHelper(gridSize, gridDivisions, 0x000000, 0x000000); // Black grid
        sceneContentGroup.add(grid);

        // Grid snapping configuration
        const gridSnapConfig = {
            translation: {
                enabled: true,
                size: 0.5 // Grid unit size for translation
            },
            rotation: {
                enabled: true,
                increment: Math.PI / 12 // 15 degrees in radians
            },
            scale: {
                enabled: true,
                increment: 0.5,
                minScale: 0.1
            }
        };

        // Initialize grid snap button state (grid snap is enabled by default)
        updateGridSnapButtonState();

        // Grid snapping utility functions
        function snapToGrid(value, gridSize) {
            return Math.round(value / gridSize) * gridSize;
        }

        function snapRotation(angle, increment) {
            return Math.round(angle / increment) * increment;
        }

        function snapScale(scale, increment, minScale) {
            const snapped = Math.round(scale / increment) * increment;
            return Math.max(snapped, minScale);
        }

        // Add CSS2DRenderer for axis labels
        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Create axis indicator labels
        function createAxisLabel(text, position, color) {
            const labelDiv = document.createElement('div');
            labelDiv.textContent = text;
            labelDiv.style.color = '#000000'; // Black text for white background
            labelDiv.style.fontSize = '24px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.fontFamily = 'Arial, sans-serif';
            labelDiv.style.textShadow = '1px 1px 2px rgba(255,255,255,0.8)'; // White shadow for contrast
            labelDiv.style.pointerEvents = 'none';
            
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.copy(position);
            return label;
        }

        // Add axis labels (positioned at axis endpoints, slightly above the lines)
        const xLabel = createAxisLabel('+X', new THREE.Vector3(75, 2, 0), '#ff0000');
        const xNegLabel = createAxisLabel('-X', new THREE.Vector3(-75, 2, 0), '#ff0000');
        const zLabel = createAxisLabel('+Z', new THREE.Vector3(0, 2, 75), '#0000ff');
        const zNegLabel = createAxisLabel('-Z', new THREE.Vector3(0, 2, -75), '#0000ff');

        sceneContentGroup.add(xLabel);
        sceneContentGroup.add(xNegLabel);
        sceneContentGroup.add(zLabel);
        sceneContentGroup.add(zNegLabel);

        // Add colorful axis lines
        function createAxisLine(origin, direction, color, length = 10) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                origin,
                new THREE.Vector3().copy(origin).add(direction.clone().multiplyScalar(length))
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                linewidth: 5,
                depthTest: true  // Enable depth testing so they render below planes and grid
            });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        // Create axis lines (positioned on the grid plane, spanning full grid)
        // X-axis: Red line from (-50, 0, 0) to (+50, 0, 0) - spans the grid width
        const xAxis = createAxisLine(new THREE.Vector3(-50, -0.1, 0), new THREE.Vector3(1, 0, 0), 0xff0000, 100);
        // Z-axis: Blue line from (0, 0, -50) to (0, 0, +50) - spans the grid depth  
        const zAxis = createAxisLine(new THREE.Vector3(0, -0.1, -50), new THREE.Vector3(0, 0, 1), 0x0000ff, 100);

        sceneContentGroup.add(xAxis);
        sceneContentGroup.add(zAxis);

        // Create a plane for the image (initially invisible)
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
        const imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        imagePlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
        imagePlane.visible = false; // Hide until image loads
        sceneContentGroup.add(imagePlane);

        // OrbitControls for interaction
        const controls = new THREE.OrbitControls(activeCamera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.4;

        controls.update();

        function setView(camera) {

            controls.reset();

            activeCamera = camera;
            controls.object = camera;
            transformControlss.camera = camera;

            // Exit plane mode if switching away from top view while in plane mode
            if (camera !== cameras.top && planeMode) {
                exitPlaneMode();
            }

            if (camera === cameras.top) {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 0, -1); // Ensure consistent up vector for top view
            } else if (camera === cameras.front) {
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 1, 0);
            } else if (camera === cameras.left) {
                camera.position.set(-10, 0, 0);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 1, 0);
            }

            // Update projection matrices
            if (camera.isOrthographicCamera) {
                updateOrthoCameras();
            }

            // Toggle top view lines based on camera
            const isTopView = (camera === cameras.top);

            // Clean up existing top view lines and spheres
            planes.forEach(plane => {
                if (plane.mesh.userData.topViewLine) {
                    sceneContentGroup.remove(plane.mesh.userData.topViewLine);
                    plane.mesh.userData.topViewLine = null;
                }
                if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach(sphere => {
                        sceneContentGroup.remove(sphere);
                    });
                    plane.mesh.userData.topViewSpheres = null;
                }
                plane.mesh.visible = true; // Make sure all planes are visible by default
            });

            // Detach transform controls if they're attached to a top view line
            if (transformControlss && transformControlss.object) {
                // Check if transform controls are attached to a top view line
                const isTopViewLine = transformControlss.object.userData && transformControlss.object.userData.parentPlane;
                if (isTopViewLine) {
                    transformControlss.detach();
                }
            }

            // If in top view, create top view lines
            if (isTopView) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                    // Ensure spheres are selectable
                    if (plane.mesh.userData.topViewSpheres) {
                        plane.mesh.userData.topViewSpheres.forEach(sphere => {
                            sphere.userData.isSelectable = true;
                        });
                    }
                });
            }

            if (camera.isPerspectiveCamera) {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
                controls.enableRotate = true;
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = Math.PI;
            } else if (camera === cameras.top) {
                // Top view: right-click to rotate (2D only - like spinning a vinyl record)
                // Camera and grid stay parallel; rotation is azimuth-only around Y axis
                controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
                controls.enableRotate = true;
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = 0;  // Lock polar angle - camera always looks straight down
            } else {
                controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
                controls.enableRotate = false;
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = Math.PI;
            }
            controls.update();
            
            // Update transform controls to apply view-specific settings
            updateTransformControls();
        }
        // setView(activeCamera);

        // Helper function to remove all top view lines and spheres
        function removeAllTopViewElements() {
            planes.forEach(plane => {
                if (plane.mesh.userData.topViewLine) {
                    sceneContentGroup.remove(plane.mesh.userData.topViewLine);
                    plane.mesh.userData.topViewLine = null;
                }
                if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach(sphere => {
                        sceneContentGroup.remove(sphere);
                    });
                    plane.mesh.userData.topViewSpheres = null;
                }
            });
        }

        // Function to create top view line for a plane
        // Helper function to get the two edge vertices of a plane
        function getPlaneEdgeVertices(plane) {
            const halfWidth = plane.width / 2;
            const halfHeight = plane.height / 2;
            
            // Local corners (width along X, height along Y)
            const localCorners = [
                new THREE.Vector3(-halfWidth, -halfHeight, 0),  // Bottom-left
                new THREE.Vector3(halfWidth, -halfHeight, 0),   // Bottom-right
                new THREE.Vector3(halfWidth, halfHeight, 0),    // Top-right
                new THREE.Vector3(-halfWidth, halfHeight, 0)     // Top-left
            ];
            
            // Get world position and quaternion (important for grouped planes)
            const worldPosition = new THREE.Vector3();
            const worldQuaternion = new THREE.Quaternion();
            plane.mesh.getWorldPosition(worldPosition);
            plane.mesh.getWorldQuaternion(worldQuaternion);
            
            // Transform to world space using the mesh's actual world quaternion and position
            const worldCorners = localCorners.map(corner => {
                const worldCorner = corner.clone();
                worldCorner.applyQuaternion(worldQuaternion);
                worldCorner.add(worldPosition);
                return worldCorner;
            });
            
            // Find the two vertices that are furthest apart (the width edges)
            let maxDistance = 0;
            let edge1 = worldCorners[0];
            let edge2 = worldCorners[1];
            
            for (let i = 0; i < worldCorners.length; i++) {
                for (let j = i + 1; j < worldCorners.length; j++) {
                    const distance = worldCorners[i].distanceTo(worldCorners[j]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        edge1 = worldCorners[i];
                        edge2 = worldCorners[j];
                    }
                }
            }
            
            return { edge1, edge2 };
        }

        function createTopViewLine(plane) {
            // Remove existing top view line if it exists
            if (plane.mesh.userData.topViewLine) {
                sceneContentGroup.remove(plane.mesh.userData.topViewLine);
                plane.mesh.userData.topViewLine = null;
            }
            
            // Remove existing spheres if they exist
            if (plane.mesh.userData.topViewSpheres) {
                plane.mesh.userData.topViewSpheres.forEach(sphere => {
                    sceneContentGroup.remove(sphere);
                });
                plane.mesh.userData.topViewSpheres = null;
            }
            
            // Create a line geometry representing the plane's length with fixed width
            const lineGeometry = new THREE.BufferGeometry();
            
            // Use the plane's width as the line length, with fixed width of 0.5
            const lineLength = plane.width;
            const fixedWidth = 0.3;
            
            // Create points for a simple line representing the plane's length
            const points = [
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2) // Close the loop
            ];
            
            // Apply the plane's rotation to the points
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
                plane.incline * Math.PI / 180,
                plane.angle * Math.PI / 180,
                0
            ));
            
            points.forEach(point => {
                point.applyMatrix4(rotationMatrix);
            });
            
            lineGeometry.setFromPoints(points);
            
            // Create line material with plane's color
            const lineMaterial = new THREE.LineBasicMaterial({
                color: plane.color, // Use plane's color
                linewidth: 10
            });
            
            // Create the line mesh
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            // Position the line at the plane's WORLD position (important for grouped planes)
            const worldPosition = new THREE.Vector3();
            plane.mesh.getWorldPosition(worldPosition);
            line.position.copy(worldPosition);
            
            // Store reference to the parent plane
            line.userData.parentPlane = plane;
            
            // Store initial dimensions and rotation for change detection
            line.userData.lastWidth = plane.width;
            line.userData.lastAngle = plane.angle;
            line.userData.lastIncline = plane.incline;
            
            // Store reference to the line in the plane's userData
            plane.mesh.userData.topViewLine = line;
            
            // Create small spheres at the edges for width control
            const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 12); // Larger spheres for easier clicking
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: plane.color,
                transparent: true,
                opacity: 0.9
                // MeshBasicMaterial doesn't respond to lighting, giving a flat 2D appearance
            });
            
            // Get the actual edge vertices of the plane
            const { edge1, edge2 } = getPlaneEdgeVertices(plane);
            
            // Create two spheres at the actual edge positions
            const sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            const sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            // IMPORTANT: Initialize userData BEFORE setting any properties
            sphere1.userData = {};
            sphere2.userData = {};
            
            // Position spheres at the actual edge vertices (X-Z coordinates only)
            sphere1.position.set(edge1.x, 0, edge1.z);
            sphere2.position.set(edge2.x, 0, edge2.z);
            
            // console.log(`Sphere positions from plane edges: (${edge1.x.toFixed(2)}, ${edge1.z.toFixed(2)}) to (${edge2.x.toFixed(2)}, ${edge2.z.toFixed(2)})`);
            
            // Store reference to parent plane and sphere index
            sphere1.userData.parentPlane = plane;
            sphere1.userData.sphereIndex = 0; // Left sphere
            sphere1.userData.isSelectable = true; // Set immediately after parentPlane
            
            sphere2.userData.parentPlane = plane;
            sphere2.userData.sphereIndex = 1; // Right sphere
            sphere2.userData.isSelectable = true; // Set immediately after parentPlane
            
            
            // Store spheres in plane's userData
            plane.mesh.userData.topViewSpheres = [sphere1, sphere2];
            
            // Set rendering order to ensure spheres appear on top of lines
            // Higher renderOrder values render on top
            line.renderOrder = 1;
            sphere1.renderOrder = 10; // Much higher to ensure they're always on top
            sphere2.renderOrder = 10;
            
            // Disable depth test for spheres so they always render on top
            sphere1.material.depthTest = false;
            sphere2.material.depthTest = false;
            
            // Add to scene (in content group for top-view rotation)
            sceneContentGroup.add(line);
            sceneContentGroup.add(sphere1);
            sceneContentGroup.add(sphere2);
            
            // Ensure spheres are always selectable (double-check)
            sphere1.userData.isSelectable = true;
            sphere2.userData.isSelectable = true;
        }

        // Function to update top view line when plane changes
        function updateTopViewLine(plane) {
            if (!plane || !plane.mesh) {
                return;
            }
            
            // If no top view line exists, create one
            if (!plane.mesh.userData.topViewLine) {
                createTopViewLine(plane);
                return;
            }
            
                const line = plane.mesh.userData.topViewLine;
                
                // Get the plane's current world position
                const worldPosition = new THREE.Vector3();
                plane.mesh.getWorldPosition(worldPosition);
                
            // Update the line's position to match plane's world position
                line.position.copy(worldPosition);
            
            // Update the line geometry to match current plane rotation
            const lineLength = plane.width;
            const fixedWidth = 0.3;
            
            // Create new points based on current rotation
            const points = [
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2) // Close the loop
            ];
            
            // Apply the plane's rotation to the points
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
                plane.incline * Math.PI / 180,
                plane.angle * Math.PI / 180,
                0
            ));
            
            points.forEach(point => {
                point.applyMatrix4(rotationMatrix);
            });
            
            // Update the line geometry with new points
            line.geometry.setFromPoints(points);
                
                // Update spheres position if they exist
                if (plane.mesh.userData.topViewSpheres) {
                    const spheres = plane.mesh.userData.topViewSpheres;
                    
                    // Get the actual edge vertices of the plane
                    const { edge1, edge2 } = getPlaneEdgeVertices(plane);
                    
                    // Update sphere positions to match actual plane edges
                if (spheres[0] && spheres[1]) {
                    spheres[0].position.set(edge1.x, 0, edge1.z);
                    spheres[1].position.set(edge2.x, 0, edge2.z);
                }
                }
                
            // Check if dimensions changed significantly - if so, recreate for clean geometry
                const currentWidth = plane.width;
                const currentAngle = plane.angle;
                const currentIncline = plane.incline;
                
            // Only recreate if width changed significantly (rotation/position updates are handled above)
            if (line.userData.lastWidth && Math.abs(line.userData.lastWidth - currentWidth) > 0.01) {
                // Width changed, recreate everything for clean geometry
                    sceneContentGroup.remove(line);
                    if (plane.mesh.userData.topViewSpheres) {
                        plane.mesh.userData.topViewSpheres.forEach(sphere => {
                            sceneContentGroup.remove(sphere);
                        });
                    }
                    createTopViewLine(plane);
                    
                    // Ensure newly created spheres are selectable
                    if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach((sphere, index) => {
                            sphere.userData.isSelectable = true;
                        sphere.userData.parentPlane = plane;
                        sphere.userData.sphereIndex = index;
                    });
                }
            } else {
                // Just store current values for next comparison
                line.userData.lastWidth = currentWidth;
                line.userData.lastAngle = currentAngle;
                line.userData.lastIncline = currentIncline;
            }
        }

        // Function to update top view line color
        function updateTopViewLineColor(plane, color) {
            if (activeCamera === cameras.top && plane.mesh.userData.topViewLine) {
                plane.mesh.userData.topViewLine.material.color.setHex(color);
                
                // Update sphere colors as well
                if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach(sphere => {
                        sphere.material.color.setHex(color);
                    });
                }
            }
        }

        // Function to visualize the normal direction of a receiver plane
        function visualizeNormal(plane) {
            // Remove existing arrow if any
            removeNormalArrow();
            
            // Check if visualization is enabled
            if (!showNormalArrow) {
                return;
            }
            
            // Only show for receiver planes
            if (plane.type !== "Receiver") {
                return;
            }
            
            // Get the plane's actual normal from its mesh orientation
            // PlaneGeometry default normal is (0, 0, 1) in local space
            const normal = new THREE.Vector3(0, 0, 1);
            
            // Apply the mesh's rotation to get the world-space normal
            normal.applyQuaternion(plane.mesh.quaternion);
            normal.normalize();
            
            // Apply positive/negative setting
            if (plane.positive) {
                normal.negate();
            }
            
            // Get plane center position from mesh
            const origin = plane.mesh.position.clone();
            
            // Calculate arrow length based on plane size (about 120% of the smaller dimension for longer visibility)
            const arrowLength = Math.min(plane.width, plane.height) * 1.5
            ;
            
            // Create arrow color - Black for both directions
            const arrowColor = 0x000000; // Black for both positive and negative
            
            // Create the arrow helper with larger, more visible proportions
            normalArrow = new THREE.ArrowHelper(
                normal,           // direction
                origin,           // origin
                arrowLength,      // length
                arrowColor,       // color
                arrowLength * 0.4, // headLength (40% of arrow length - larger head)
                arrowLength * 0.3  // headWidth (30% of arrow length - wider head)
            );
            
            // Make the arrow much more visible with thicker line
            normalArrow.line.material.linewidth = 6;
            
            // Add to scene
            sceneContentGroup.add(normalArrow);
        }
        
        // Function to remove the normal arrow
        function removeNormalArrow() {
            if (normalArrow) {
                sceneContentGroup.remove(normalArrow);
                // ArrowHelper doesn't have dispose(), but we should clean up its children
                if (normalArrow.line) {
                    normalArrow.line.geometry.dispose();
                    normalArrow.line.material.dispose();
                }
                if (normalArrow.cone) {
                    normalArrow.cone.geometry.dispose();
                    normalArrow.cone.material.dispose();
                }
                normalArrow = null;
            }
        }

        let scalingcheck = false;
        let aspect = null;

        // 5. Handle image upload
        document.getElementById("imageInput").addEventListener("change", imageupload);

        let targetHeight = 10;

        function imageupload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check if file is an image (PNG, JPG, etc.)
            if (!file.type.match("image.*")) {
                alert("Please upload an image file (PNG, JPG, etc.)");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const imageUrl = e.target.result;

                //to read the image dimension 
                const img = new Image();
                img.onload = function () {
                    aspect = img.width / img.height;
                    const targetHeight = 10;
                    const targetWidth = targetHeight * aspect;

                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
                }
                const texture = new THREE.TextureLoader().load(imageUrl, function (texture) {
                    // Success: Apply texture to the plane
                    imagePlane.material.map = texture;
                    imagePlane.material.needsUpdate = true;
                    imagePlane.visible = true;
                    grid.visible = true; // Hide grid
                }, undefined, (error) => {
                    console.error("Error loading image:", error);
                    alert("Failed to load image. Try another file.");
                });
                img.src = imageUrl;
                event.target.value = '';
            };
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                alert("Error reading file. Try again.");
            };
            reader.readAsDataURL(file);
        }

        // Array to store all planes
        const planes = [];
        let selectedPlane = null;
        let gui = new dat.GUI();
        gui.domElement.classList.add("my-custom-gui");
        let transformControls = null;

        //new bit for scaling
        let isMeasuring = false;
        let measurePoints = [];
        let tempSpheres = []; // Array to store temporary spheres

        function handleMeasurementClick(event) {
            if (!isMeasuring) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cameras.top);

            // Check intersections with all scene objects (more reliable)
            const intersects = raycaster.intersectObject(imagePlane);
            let distance = null;

            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                
                // Create temporary sphere at clicked point
                const sphereGeometry = new THREE.SphereGeometry(0.05, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(point);
                sceneContentGroup.add(sphere);
                tempSpheres.push(sphere);
                
                if (measurePoints.length === 2) {
                    distance = measurePoints[0].distanceTo(measurePoints[1]);
                    
                    // Show input modal
                    showScaleInputModal();
                }
            }
            return distance;
        }

        function cleanupMeasurement() {
            // Remove temporary spheres
            tempSpheres.forEach(sphere => {
                if (sphere.parent) sphere.parent.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            });
            tempSpheres = [];
            
            measurePoints = [];
            isMeasuring = false;
            renderer.domElement.removeEventListener('click', handleMeasurementClick);
        }

        function handleScalingClick(event) {
            scalingdist = handleMeasurementClick(event);
        }

        function showScaleInputModal() {
            const modal = document.getElementById('scaleInputModal');
            const input = document.getElementById('scaleDistanceInput');
            modal.style.display = 'block';
            input.focus();
        }

        function hideScaleInputModal() {
            const modal = document.getElementById('scaleInputModal');
            modal.style.display = 'none';
        }

        function confirmScaleInput() {
            const input = document.getElementById('scaleDistanceInput');
            const inputValue = parseFloat(input.value);
            
            if (!inputValue || inputValue <= 0) {
                alert("Please enter a valid distance");
                return;
            }
            
            // Update the scaling
            updatemeasureplane(inputValue);
            
            // Clean up
            cleanupMeasurement();
            hideScaleInputModal();
            input.value = '';
        }

        let scalingdist = null;
        document.getElementById("scalingbutton").addEventListener("click", function () {
            setView(cameras.top);
            isMeasuring = true;
            scalingcheck = true;
            measurePoints = [];
            
            // Clear any existing temporary spheres
            tempSpheres.forEach(sphere => {
                if (sphere.parent) sphere.parent.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            });
            tempSpheres = [];

            // Add temporary click listener
            renderer.domElement.removeEventListener('click', handleScalingClick);
            renderer.domElement.addEventListener('click', handleScalingClick);
        });

        // Modal event listeners
        document.getElementById("confirmScale").addEventListener("click", confirmScaleInput);
        
        document.getElementById("scaleDistanceInput").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                confirmScaleInput();
            }
        });

        function updatemeasureplane(input) {
            if (!scalingdist || !aspect) {
                console.error("Measurement data not available");
                return;
            }

            // Calculate scaling factor
            let scalingfactor = input / scalingdist;
            const newtargetHeight = targetHeight * scalingfactor;
            const newtargetWidth = newtargetHeight * aspect;

            targetHeight = newtargetHeight;

            // Preserve current material and visibility
            const currentMaterial = imagePlane.material;
            const currentVisibility = imagePlane.visible;
            const currentPosition = imagePlane.position.clone();
            const currentRotation = imagePlane.rotation.clone();

            // Dispose old geometry and create new one
            imagePlane.geometry.dispose();
            imagePlane.geometry = new THREE.PlaneGeometry(newtargetWidth, newtargetHeight);

            // Restore properties
            imagePlane.material = currentMaterial;
            imagePlane.visible = currentVisibility;
            imagePlane.position.copy(currentPosition);
            imagePlane.rotation.copy(currentRotation);

        }
        let nextId = 1;
        function generateId() {
            return nextId++;
        }

        // Sphere selection and dragging functions
        function selectSphere(sphere) {
            // Deselect all spheres first
            deselectAllSpheres();
            
            // Select only the clicked sphere
            selectedSphere = sphere;
            sphereOriginalColor = sphere.material.color.getHex();
            sphere.material.color.setHex(0x000000); // Black when selected
        }

        function deselectAllSpheres() {
            // Deselect all spheres in all planes
            planes.forEach(plane => {
                if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach(sphere => {
                        // Restore original color (plane color)
                        const plane = sphere.userData.parentPlane;
                        sphere.material.color.setHex(plane.color);
                        sphere.material.opacity = 0.9;
                    });
                }
            });
            
            selectedSphere = null;
            sphereOriginalColor = null;
            hoveredSphere = null;
            
            // Reset double-click tracking
            lastClickedSphere = null;
            lastSphereClickTime = 0;
        }

        function deselectSphere() {
            if (selectedSphere) {
                // Restore original color (plane color)
                const plane = selectedSphere.userData.parentPlane;
                selectedSphere.material.color.setHex(plane.color);
                selectedSphere.material.opacity = 0.9;
                selectedSphere = null;
                sphereOriginalColor = null;
            }
            
            // Reset double-click tracking
            lastClickedSphere = null;
            lastSphereClickTime = 0;
        }

        function startSphereDrag(sphere, mousePosition) {
            if (activeCamera !== cameras.top) return;
            
            isDraggingSphere = true;
            dragStartPosition.copy(mousePosition);
            
            // Disable orbit controls during sphere dragging
            controls.enabled = false;
            
            // Note: Sphere dragging doesn't use transform controls, so no need to disable grid snap
        }

        function updateSphereDrag(mousePosition) {
            if (!isDraggingSphere || !selectedSphere) return;
            
            // Calculate drag delta in X-Z plane
            const deltaX = mousePosition.x - dragStartPosition.x;
            const deltaZ = mousePosition.z - dragStartPosition.z;
            
            // Update sphere position
            selectedSphere.position.x += deltaX;
            selectedSphere.position.z += deltaZ;
            
            // Update drag start position for next frame
            dragStartPosition.copy(mousePosition);
            
            // Update wireframe in real-time during dragging
            updateWireframeFromSpheres();
        }

        function endSphereDrag() {
            if (isDraggingSphere) {
                isDraggingSphere = false;
                
                // Update plane geometry and rotation after dragging is complete
                if (selectedSphere) {
                    const plane = selectedSphere.userData.parentPlane;
                    const spheres = plane.mesh.userData.topViewSpheres;
                    
                    if (spheres && spheres.length === 2) {
                        // Get final sphere positions
                        const sphere1Pos = spheres[0].position.clone();
                        const sphere2Pos = spheres[1].position.clone();
                        
                        // Calculate new plane center
                        const centerX = (sphere1Pos.x + sphere2Pos.x) / 2;
                        const centerZ = (sphere1Pos.z + sphere2Pos.z) / 2;
                        
                        // Calculate new plane width
                        const newWidth = Math.sqrt(
                            Math.pow(sphere2Pos.x - sphere1Pos.x, 2) + 
                            Math.pow(sphere2Pos.z - sphere1Pos.z, 2)
                        );
                        
                        // Calculate rotation angle from sphere positions
                        const deltaX = sphere2Pos.x - sphere1Pos.x;
                        const deltaZ = sphere2Pos.z - sphere1Pos.z;
                        const newAngle = -Math.atan2(deltaZ, deltaX) * (180 / Math.PI);
                        
                        // Update plane properties
                        plane.mesh.position.x = centerX;
                        plane.mesh.position.z = centerZ;
                        plane.x = centerX;
                        plane.z = centerZ;
                        plane.width = newWidth;
                        plane.defaultWidth = newWidth;
                        plane.angle = newAngle;
                        
                        // Update plane geometry
                        plane.mesh.geometry.dispose();
                        plane.mesh.geometry = new THREE.PlaneGeometry(plane.width, plane.height);
                        
                        // Update plane rotation
                        plane.mesh.rotation.y = newAngle * (Math.PI / 180);
                    }
                    
                    // Update wireframe to reflect new plane properties
                    // But preserve the sphere positions by storing and restoring them
                    const savedSpherePositions = [];
                    if (spheres && spheres.length === 2) {
                        savedSpherePositions[0] = spheres[0].position.clone();
                        savedSpherePositions[1] = spheres[1].position.clone();
                    }
                    
                    updateTopViewLine(plane);
                    
                    // Restore sphere positions after wireframe update
                    if (savedSpherePositions.length === 2 && plane.mesh.userData.topViewSpheres) {
                        const newSpheres = plane.mesh.userData.topViewSpheres;
                        if (newSpheres.length === 2) {
                            newSpheres[0].position.copy(savedSpherePositions[0]);
                            newSpheres[1].position.copy(savedSpherePositions[1]);
                        }
                    }
                }
                
                // Deselect all spheres when dragging ends
                deselectAllSpheres();
                
                // Don't re-enable orbit controls immediately - wait for next click
                orbitControlsDisabled = true;
                
                // Note: Sphere dragging doesn't use transform controls, grid snap remains functional
            }
        }

        function updateWireframeFromSpheres() {
            if (!selectedSphere) return;
            
            const plane = selectedSphere.userData.parentPlane;
            const spheres = plane.mesh.userData.topViewSpheres;
            
            if (!spheres || spheres.length !== 2) return;
            
            // Get current sphere positions
            const sphere1Pos = spheres[0].position.clone();
            const sphere2Pos = spheres[1].position.clone();
            
            // Update wireframe to directly connect the two spheres
            if (plane.mesh.userData.topViewLine) {
                const line = plane.mesh.userData.topViewLine;
                
                // Calculate the vector from sphere1 to sphere2
                const direction = new THREE.Vector3();
                direction.subVectors(sphere2Pos, sphere1Pos);
                const distance = direction.length();
                
                // Create wireframe points that connect the spheres
                const fixedWidth = 0.3;
                const halfWidth = fixedWidth / 2;
                
                // Create a rectangle that connects the two spheres
                const points = [
                    new THREE.Vector3(sphere1Pos.x, 0, sphere1Pos.z - halfWidth),
                    new THREE.Vector3(sphere2Pos.x, 0, sphere2Pos.z - halfWidth),
                    new THREE.Vector3(sphere2Pos.x, 0, sphere2Pos.z + halfWidth),
                    new THREE.Vector3(sphere1Pos.x, 0, sphere1Pos.z + halfWidth),
                    new THREE.Vector3(sphere1Pos.x, 0, sphere1Pos.z - halfWidth)
                ];
                
                // Update line geometry to connect the spheres
                line.geometry.dispose();
                line.geometry = new THREE.BufferGeometry();
                line.geometry.setFromPoints(points);
                
                // Position the line at the origin (since points are in world coordinates)
                line.position.set(0, 0, 0);
                line.rotation.set(0, 0, 0);
            }
        }

        function updatePlaneFromSphereDrag() {
            if (!selectedSphere) return;
            
            // During dragging, we only move the selected sphere
            // The plane geometry will be updated after dragging is complete
            // This prevents the other sphere from moving
            
        }

        // Multi-select functions for height and type changes
        function changeMultiplePlanesHeight(newHeight) {
            if (selectedPlanes.length < 2) return;
            
            captureState("Change multiple planes height");
            
            selectedPlanes.forEach(planeData => {
                // Update height
                planeData.height = newHeight;
                planeData.defaultHeight = newHeight;
                
                // Update geometry
                planeData.mesh.geometry.dispose();
                planeData.mesh.geometry = new THREE.PlaneGeometry(planeData.width, planeData.height);
                planeData.mesh.scale.set(1, 1, 1);
                
                // Update top view line if in top view
                if (activeCamera === cameras.top) {
                    updateTopViewLine(planeData);
                    // Ensure spheres are selectable after update
                    if (planeData.mesh.userData.topViewSpheres) {
                        planeData.mesh.userData.topViewSpheres.forEach(sphere => {
                            sphere.userData.isSelectable = true;
                        });
                    }
                }
            });
        }

        function changeMultiplePlanesType(newType) {
            if (selectedPlanes.length < 2) return;
            
            captureState("Change multiple planes type");
            
            selectedPlanes.forEach(planeData => {
                // Update type
                planeData.type = newType;
                
                // Update color based on type
                const typeLower = String(newType || '').toLowerCase();
                let hex = 0xe6c200; // receiver default (dark yellow)
                if (typeLower === 'emitter') {
                    hex = 0xff0000; // emitter red
                } else if (typeLower === 'inert') {
                    hex = 0x0000ff; // inert blue
                }
                planeData.color = hex;
                
                // Keep selection highlight
                planeData.mesh.material.color.setHex(0x808080);
                
                // Update top view line color if in top view
                updateTopViewLineColor(planeData, 0x808080);
                
                // Reset temperature for non-emitters
                if (typeLower !== 'emitter') {
                    planeData.temperature = 0;
                }
                
                // Update normal arrow visualization for receiver planes
                if (newType === "Receiver") {
                    visualizeNormal(planeData);
                }
            });
        }

        // Function to change temperature (Heat Flux) for all selected emitter planes
        function changeMultiplePlanesTemperature(newTemperature) {
            if (selectedPlanes.length < 2) return;
            
            captureState("Change multiple planes temperature");
            
            // Count how many emitters were updated
            let emitterCount = 0;
            
            selectedPlanes.forEach(planeData => {
                // Only update temperature for emitter planes
                if (planeData.type === 'Emitter') {
                    planeData.temperature = newTemperature;
                    emitterCount++;
                }
            });
            
            // Log if no emitters were found
            if (emitterCount === 0) {
                console.warn('No emitter planes in selection to update temperature');
            }
        }

        // Function to create a new plane
        function createPlane(width = 1, height = 1, skipStateCapture = false) {
            const geometry = new THREE.PlaneGeometry(width, height);
            // Default to Receiver type with dark yellow color
            const defaultType = "Receiver";
            const defaultColorHex = 0xe6c200; // Darker yellow for better contrast
            const material = new THREE.MeshStandardMaterial({
                color: defaultColorHex,
                side: THREE.DoubleSide,
                wireframe: false,
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(0, 0, 0);
            plane.rotation.y = Math.PI * 2;
            plane.scale.set(1, 1, 1);
            const defaultName = `Plane ${planes.length + 1}`;
            // Store plane data
            const planeData = {
                id: generateId(),
                mesh: plane,
                width: width,
                height: height,
                // Store default values
                defaultWidth: width,
                defaultHeight: height,
                defaultX: 0,
                defaultY: height / 2,
                defaultZ: 0,
                defaultAngle: 0,
                defaultColor: material.color.getHex(),
                name: defaultName,
                x: plane.position.x,
                y: plane.position.y,
                z: plane.position.z,
                angle: plane.rotation.y * 180 / Math.PI,
                incline: plane.rotation.x * 180 / Math.PI,
                color: material.color.getHex(),
                temperature: 0,
                type: defaultType,
                positive: true
            };

            planes.push(planeData);
            sceneContentGroup.add(plane);

            // Make plane selectable
            plane.userData = planeData;
            if (history.length === 0) {
                initializeHistory();
            }
            
            // Only capture state if not skipped (e.g., during continuous plane creation)
            if (!skipStateCapture) {
            captureState("Plane created");
            }
            return planeData;

        }

        function resetPlaneToDefault() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState("Before reset");

            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            selectedPlanes.forEach(planeData => {
                // Reset all properties to defaults
                planeData.width = 1;
                planeData.height = 1;
                planeData.x = 0;
                planeData.y = 0.5;
                planeData.z = 0;
                planeData.angle = 0;
                planeData.incline = 0; // Reset incline to 0
                planeData.color = planeData.defaultColor;

                // Update the mesh
                planeData.mesh.geometry.dispose();
                planeData.mesh.geometry = new THREE.PlaneGeometry(
                    planeData.width,
                    planeData.height
                );

                planeData.mesh.position.set(
                    planeData.x,
                    planeData.y,
                    planeData.z
                );
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180, // x rotation (incline)
                    planeData.angle * Math.PI / 180,   // y rotation (angle)
                    0                                  // z rotation
                );
                planeData.mesh.scale.set(1, 1, 1);
                planeData.mesh.material.color.setHex(planeData.color);
            });

            // Update the GUI
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

        }

        // Add event listener for the reset button
        document.getElementById("resetPlane").addEventListener("click", resetPlaneToDefault);

        // Function to make plane stand on ground (bottom edge at y=0)
        // Uses world space so it works for both single selection and multi-selection (grouped planes).
        function standPlaneOnGround() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState("Before stand");

            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();

            selectedPlanes.forEach(planeData => {
                const mesh = planeData.mesh;
                mesh.updateMatrixWorld(true);
                mesh.getWorldPosition(worldPos);
                mesh.getWorldQuaternion(worldQuat);

                // Corners in local space (same as computeWorldCorners / generatePointsOnPlane)
                const halfWidth = planeData.width / 2;
                const halfHeight = planeData.height / 2;
                const corners = [
                    new THREE.Vector3(-halfWidth, -halfHeight, 0),
                    new THREE.Vector3(halfWidth, -halfHeight, 0),
                    new THREE.Vector3(halfWidth, halfHeight, 0),
                    new THREE.Vector3(-halfWidth, halfHeight, 0)
                ];

                // Transform corners to world space
                const worldCorners = corners.map(corner => {
                    const wc = corner.clone().applyQuaternion(worldQuat).add(worldPos);
                    return wc;
                });

                const minY = Math.min(...worldCorners.map(c => c.y));
                const yOffset = -minY;
                const newWorldY = worldPos.y + yOffset;

                // Update plane data (world position)
                planeData.x = worldPos.x;
                planeData.y = newWorldY;
                planeData.z = worldPos.z;

                if (selectedPlaneGroup && mesh.parent === selectedPlaneGroup) {
                    // Multi-selection: mesh is in group; store new world position and set local position
                    const newWorldPos = new THREE.Vector3(worldPos.x, newWorldY, worldPos.z);
                    if (originalPositions.has(planeData)) {
                        originalPositions.get(planeData).worldPosition.copy(newWorldPos);
                    }
                    mesh.parent.worldToLocal(newWorldPos);
                    mesh.position.copy(newWorldPos);
                } else {
                    // Single selection: mesh is directly in scene; position is world
                    mesh.position.set(worldPos.x, newWorldY, worldPos.z);
                }
            });

            // If we have a group, recenter it so local positions stay consistent
            if (selectedPlaneGroup && selectedPlanes.length > 1) {
                updateGroupPosition();
            }

            if (activeCamera === cameras.top) {
                selectedPlanes.forEach(plane => updateTopViewLine(plane));
            }

            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                if (showNormalArrow && selectedPlanes[selectedPlanes.length - 1].type === "Receiver") {
                    visualizeNormal(selectedPlanes[selectedPlanes.length - 1]);
                }
            }

            captureState("After stand");
        }

        // Add event listener for the stand button
        document.getElementById("standPlane").addEventListener("click", standPlaneOnGround);

        function deleteplanefn() {
            if (selectedPlanes.length === 0) return;

            captureState("Before delete");

            // Filter out planes that no longer exist (check planes array and mesh validity)
            // Note: Don't check scene.children because multi-selected planes are in selectedPlaneGroup, not scene
            const validSelectedPlanes = selectedPlanes.filter(planeData => {
                return planes.includes(planeData) && planeData.mesh && planeData.mesh.parent;
            });

            if (validSelectedPlanes.length === 0) {
                console.warn('No valid planes to delete');
                selectedPlanes = [];
                return;
            }

            // Delete all valid selected planes
            validSelectedPlanes.forEach(planeData => {
                // Detach transform controls if they're attached to this plane or its group
                if (transformControlss.object === planeData.mesh || 
                    (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup)) {
                    transformControlss.detach();
                }

                // Remove the plane mesh from its parent (could be scene or selectedPlaneGroup)
                if (planeData.mesh.parent) {
                    planeData.mesh.parent.remove(planeData.mesh);
                }

                // Remove top view line if it exists
                if (planeData.mesh.userData.topViewLine) {
                    sceneContentGroup.remove(planeData.mesh.userData.topViewLine);
                    planeData.mesh.userData.topViewLine = null;
                }

                // Remove top view spheres if they exist
                if (planeData.mesh.userData.topViewSpheres) {
                    planeData.mesh.userData.topViewSpheres.forEach(sphere => {
                        sceneContentGroup.remove(sphere);
                    });
                    planeData.mesh.userData.topViewSpheres = null;
                }

                const index = planes.indexOf(planeData);
                if (index > -1) {
                    planes.splice(index, 1);
                }

                planeData.mesh.geometry.dispose();
                planeData.mesh.material.dispose();
            });

            // Clear group if it exists
            if (selectedPlaneGroup) {
                sceneContentGroup.remove(selectedPlaneGroup);
                selectedPlaneGroup = null;
                originalPositions.clear();
            }

            gui.destroy();
            gui = new dat.GUI();
            selectedPlanes = [];
            removeNormalArrow(); // Remove arrow when planes are deleted
            captureState();
        }

        document.getElementById("deleteplane").addEventListener("click", deleteplanefn);

        /**
         * Override DAT.GUI number controller display to force consistent decimal precision.
         * Fixes known DAT.GUI 0.7.7 behavior where step(0.1) rounds values >=10 to integers in display.
         * @param {dat.GUI.Controller} controller - The number controller to fix
         * @param {number} decimals - Number of decimal places to always show (default: 1)
         */
        function forceDatGuiDecimalPrecision(controller, decimals = 1) {
            if (!controller) return;
            const input = controller.__input || (controller.domElement && controller.domElement.querySelector('input'));
            if (!input) return;
            const formatValue = () => {
                try {
                    if (document.activeElement === input) return;
                    const val = controller.getValue();
                    if (typeof val === 'number' && !isNaN(val)) {
                        const formatted = Number(val).toFixed(decimals);
                        if (input.value !== formatted) input.value = formatted;
                    }
                } catch (e) {}
            };
            const origUpdateDisplay = controller.updateDisplay && controller.updateDisplay.bind(controller);
            if (typeof origUpdateDisplay === 'function') {
                controller.updateDisplay = function() {
                    origUpdateDisplay();
                    formatValue();
                };
            }
            formatValue();
            input.addEventListener('blur', formatValue);
            const pollId = setInterval(formatValue, 150);
            setTimeout(() => clearInterval(pollId), 2000);
        }

        // Function to update GUI for selected plane(s)
        function updateGUI(planeData) {
            gui.destroy();
            gui = new dat.GUI();

            // Check if multiple planes are selected
            const isMultiSelect = selectedPlanes.length > 1;
            
            if (isMultiSelect) {
                // Multi-select GUI
                gui.add({ info: `Multiple Planes (${selectedPlanes.length})` }, 'info').name('Selection').listen();
                
                // Multi-select height control
                const multiHeightController = gui.add({ height: 1 }, 'height').name('Height (All)').step(0.1);
                forceDatGuiDecimalPrecision(multiHeightController, 1);
                multiHeightController.onChange(function (newHeight) {
                    changeMultiplePlanesHeight(newHeight);
                });
                
                // Multi-select type control
                const multiTypeController = gui.add({ type: 'Receiver' }, 'type', ['Receiver', 'Emitter', 'Inert']).name('Type (All)');
                multiTypeController.onChange(function (newType) {
                    changeMultiplePlanesType(newType);
                });
                
                // Multi-select temperature control (only affects Emitter planes)
                const emitterCount = selectedPlanes.filter(p => p.type === 'Emitter').length;
                const multiTempController = gui.add({ temperature: 0 }, 'temperature').name(`Heat Flux `);
                multiTempController.onChange(function (newTemp) {
                    changeMultiplePlanesTemperature(newTemp);
                });
                
                // Show info about selected planes
                const planeNames = selectedPlanes.map(p => p.name).join(', ');
                gui.add({ names: planeNames }, 'names').name('Selected Planes').listen();
                
                return;
            }

            // Single plane GUI (existing functionality)
            const nameController = gui.add(planeData, 'name').name('Name');
            nameController.onChange(function (newName) {
                // Trim whitespace
                newName = newName.trim();
                
                // Check for empty name
                if (!newName) {
                    alert('Name cannot be empty! Please provide a valid name.');
                    nameController.setValue(planeData.name);
                    return;
                }
                
                // Check for duplicate names
                const nameExists = planes.some(p => p !== planeData && p.name === newName);
                if (nameExists) {
                    alert(`This name already exists! Please choose a different name.\n\nExisting planes: ${planes.map(p => p.name).join(', ')}`);
                    nameController.setValue(planeData.name);
                    return;
                }
                
                planeData.name = newName;
                captureState();
            });

            // Add controllers with explicit state capture
            const controllers = {
                width: gui.add(planeData, 'width').name('Width').step(0.1),
                height: gui.add(planeData, 'height').name('Height').step(0.1),
                x: gui.add(planeData, 'x').name('X-position').step(0.1),
                y: gui.add(planeData, 'y').name('Y-position').step(0.1),
                z: gui.add(planeData, 'z').name('Z-position').step(0.1),
                angle: gui.add(planeData, 'angle', -180, 180).name('Rotation').step(1),
                incline: gui.add(planeData, 'incline', -180, 180).name("Inclination").step(1),
                temp: gui.add(planeData, "temperature").name("Heat Flux"),
                type: gui.add(planeData, "type", ["Receiver", "Emitter", "Inert"]).name("Type"),
                positive: gui.add(planeData, "positive").name("Normal Direction -"),
            };

            // Fix DAT.GUI display: force 1 decimal place for position/size (values >=10 otherwise show as integers)
            ['width', 'height', 'x', 'y', 'z'].forEach(key => forceDatGuiDecimalPrecision(controllers[key], 1));

            // Track previous values
            controllers.width.__oldValue = planeData.width;
            controllers.height.__oldValue = planeData.height;

            // Single onChange handler for all properties
            function handleGUIChange() {
                // Handle geometry changes
                if (controllers.width.__oldValue !== planeData.width ||
                    controllers.height.__oldValue !== planeData.height) {

                    planeData.defaultWidth = planeData.width;
                    planeData.defaultHeight = planeData.height;

                    planeData.mesh.geometry.dispose();
                    planeData.mesh.geometry = new THREE.PlaneGeometry(
                        planeData.width,
                        planeData.height
                    );

                    planeData.mesh.scale.set(1, 1, 1);

                    controllers.width.__oldValue = planeData.width;
                    controllers.height.__oldValue = planeData.height;
                    
                    // Update top view line if in top view
                    if (activeCamera === cameras.top) {
                        updateTopViewLine(planeData);
                    }
                }

                // Update position and rotation
                planeData.mesh.position.set(planeData.x, planeData.y, planeData.z);
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180,
                    planeData.angle * Math.PI / 180,
                    0
                );

                // Update top view line if in top view and position/rotation changed
                if (activeCamera === cameras.top) {
                    updateTopViewLine(planeData);
                }

                // Ensure temperature control reflects current type
                updateTemperatureControl();
                
                // Update normal arrow visualization for receiver planes
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                }

                // Always capture state after any change
                captureState();
            }

            // Add listeners to all controllers
            Object.values(controllers).forEach(controller => {
                if (controller.onChange) {
                    controller.onChange(handleGUIChange);
                }
            });

            // Helper to enable/disable a GUI controller input element
            function setControllerDisabled(controller, disabled) {
                if (!controller || !controller.domElement) return;
                const inputEl = controller.domElement.querySelector('input');
                if (inputEl) inputEl.disabled = disabled;
            }

            // Enable temp only for Emitters; otherwise set to 0 and disable
            function updateTemperatureControl() {
                const isEmitter = String(planeData.type || '').toLowerCase() === 'emitter';
                if (!isEmitter) {
                    if (planeData.temperature !== 0) {
                        planeData.temperature = 0;
                        controllers.temp.updateDisplay();
                        // Capture only when value actually changed
                        captureState();
                    }
                    setControllerDisabled(controllers.temp, true);
                } else {
                    setControllerDisabled(controllers.temp, false);
                }
            }

            // Update color by type, preserving selection highlight
            function updateColorByType() {
                const typeLower = String(planeData.type || '').toLowerCase();
                let hex = 0xe6c200; // receiver default (dark yellow)
                if (typeLower === 'emitter') {
                    hex = 0xff0000; // emitter red
                } else if (typeLower === 'inert') {
                    hex = 0x0000ff; // inert blue
                }
                planeData.color = hex;
                // If currently selected, keep highlight (yellow), otherwise set mapped color
                planeData.mesh.material.color.setHex(selectedPlanes.includes(planeData) ? 0x808080 : hex);
                
                // Update top view line color if in top view
                updateTopViewLineColor(planeData, hex);
            }

            // React immediately to Type changes
            controllers.type.onChange(function () {
                updateTemperatureControl();
                updateColorByType();
                
                // Update or remove normal arrow based on type
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                } else {
                    removeNormalArrow();
                }
                
                captureState();
            });
            
            // React to Normal Direction changes
            controllers.positive.onChange(function () {
                if (planeData.type === "Receiver" && planeData.contourData) {
                    console.warn(` Normal direction changed after calculation. You may need to recalculate for accurate results.`);
                }
                
                // Update the normal arrow visualization
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                }
                
                captureState();
            });

            // Initialize temperature control state on GUI creation
            updateTemperatureControl();
            updateColorByType();
            
            // Visualize the normal direction for receiver planes
            if (planeData.type === "Receiver") {
                visualizeNormal(planeData);
            } else {
                removeNormalArrow();
            }
        }


        // Add hover detection for spheres to provide visual feedback
        renderer.domElement.addEventListener('mousemove', (event) => {
            // Only check hover in top view
            if (activeCamera !== cameras.top) {
                if (hoveredSphere) {
                    // Clear hover state if not in top view
                    const plane = hoveredSphere.userData.parentPlane;
                    hoveredSphere.material.color.setHex(plane.color);
                    hoveredSphere.material.opacity = 0.9;
                    hoveredSphere = null;
                }
                return;
            }
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.5;
            raycaster.params.Line.threshold = 0.1;
            raycaster.setFromCamera(mouse, activeCamera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            let foundSphere = null;
            
            // Check if hovering over a sphere - prioritize spheres over other objects
            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;
                // Explicitly check for sphere geometry to ensure we're hovering over a sphere, not a line
                if (object.userData && object.userData.isSelectable && object.userData.parentPlane &&
                    object.geometry && object.geometry.type === 'SphereGeometry') {
                    foundSphere = object;
                    break; // Stop at first sphere found
                }
            }
            
            // Update hover state
            if (foundSphere !== hoveredSphere) {
                // Remove hover effect from previous sphere
                if (hoveredSphere && hoveredSphere !== selectedSphere) {
                    const prevPlane = hoveredSphere.userData.parentPlane;
                    hoveredSphere.material.color.setHex(prevPlane.color);
                    hoveredSphere.material.opacity = 0.9;
                }
                
                // Apply hover effect to new sphere
                if (foundSphere && foundSphere !== selectedSphere) {
                    // Brighten the sphere to indicate it's hoverable
                    foundSphere.material.color.setHex(0xFFFFFF); // White when hovering
                    foundSphere.material.opacity = 1.0;
                    renderer.domElement.style.cursor = 'pointer';
                } else {
                    renderer.domElement.style.cursor = 'default';
                }
                
                hoveredSphere = foundSphere;
            }
        });

        renderer.domElement.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            // Increase raycaster threshold for better sphere detection
            raycaster.params.Points.threshold = 0.5;
            raycaster.params.Line.threshold = 0.1;
            raycaster.setFromCamera(mouse, activeCamera);
            const intersects = raycaster.intersectObjects(scene.children, true);


            // Clear previous group if not holding shift and clicking empty space
            if (!isShiftPressed && selectedPlaneGroup && intersects.length === 0) {
                ungroupPlanes();
                return;
            }

            // PRIORITY 1: Check for spheres FIRST across ALL intersects (ignore distance order)
            // This ensures spheres are selected even when overlapping with lines
            if (activeCamera === cameras.top) {
            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;

                    // Check if this is a selectable sphere
                    if (object.userData && object.userData.isSelectable && object.userData.parentPlane && 
                        object.geometry && object.geometry.type === 'SphereGeometry') {
                    const sphere = object;
                        const currentTime = Date.now();
                        
                        // Check if this is a double-click on the same sphere
                        if (lastClickedSphere === sphere && (currentTime - lastSphereClickTime) < SPHERE_DOUBLE_CLICK_DELAY) {
                            // Double-click detected!
                    selectSphere(sphere);
                            
                            // Reset double-click tracking
                            lastClickedSphere = null;
                            lastSphereClickTime = 0;
                    return; // Exit early to prevent other click handlers
                        } else {
                            // First click - store for double-click detection
                            lastClickedSphere = sphere;
                            lastSphereClickTime = currentTime;
                            
                            // Give visual feedback that sphere was clicked once (pulse opacity)
                            const originalOpacity = sphere.material.opacity;
                            sphere.material.opacity = 1.0;
                            setTimeout(() => {
                                if (sphere.material) {
                                    sphere.material.opacity = originalOpacity;
                                }
                            }, SPHERE_DOUBLE_CLICK_DELAY);
                            
                            return; // Exit but don't select yet
                        }
                    }
                }
            }

            // PRIORITY 2: No spheres found, check other objects (lines, planes, etc.)
            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;

                // Check if clicked on a top view line
                if (object.userData && object.userData.parentPlane) {
                    // Reset double-click state since we're clicking on a line, not sphere
                    lastClickedSphere = null;
                    lastSphereClickTime = 0;
                    
                    const planeData = object.userData.parentPlane;
                    
                    // Ensure the plane still exists in the planes array
                    if (!planes.includes(planeData)) {
                        return;
                    }
                    
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0x808080);
                            updateTopViewLineColor(planeData, 0x808080);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);

                            // If the plane is in a group, restore its parent and position
                            if (selectedPlaneGroup && planeData.mesh.parent === selectedPlaneGroup) {
                                const original = originalPositions.get(planeData);
                                selectedPlaneGroup.remove(planeData.mesh);
                                if (original) {
                                    original.parent.add(planeData.mesh);
                                    planeData.mesh.position.copy(original.worldPosition);
                                }
                                planeData.mesh.visible = true;
                            }

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                // If only one plane left, disband group and restore visibility for all
                                ungroupPlanes();
                                planes.forEach(p => p.mesh.visible = true);
                            }
                        }
                    } else {
                        // Regular click - single selection
                        // Check if this plane is already the only selected plane
                        if (selectedPlanes.length === 1 && selectedPlanes[0] === planeData) {
                            // If clicking on the only selected plane, deselect it
                            selectedPlanes = [];
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);
                            ungroupPlanes();
                        } else {
                            // Otherwise, select this plane as the only selection
                            ungroupPlanes();
                            planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                            planes.forEach(p => p.mesh.visible = true);
                            selectedPlanes = [planeData];
                            planeData.mesh.material.color.setHex(0x808080);
                            updateTopViewLineColor(planeData, 0x808080);
                        }
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }

                // Find the plane data (might be a child of the group)
                let planeData = null;
                if (object.userData && planes.some(p => p.mesh === object)) {
                    planeData = object.userData;
                } else if (object.parent && object.parent.userData && planes.some(p => p.mesh === object.parent)) {
                    planeData = object.parent.userData;
                }

                if (planeData) {
                    // Reset double-click state since we're clicking on a plane, not sphere
                    lastClickedSphere = null;
                    lastSphereClickTime = 0;
                    
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0x808080);
                            updateTopViewLineColor(planeData, 0x808080);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);

                            // If the plane is in a group, restore its parent and position
                            if (selectedPlaneGroup && planeData.mesh.parent === selectedPlaneGroup) {
                                const original = originalPositions.get(planeData);
                                selectedPlaneGroup.remove(planeData.mesh);
                                if (original) {
                                    original.parent.add(planeData.mesh);
                                    planeData.mesh.position.copy(original.worldPosition);
                                }
                                planeData.mesh.visible = true;
                            }

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                // If only one plane left, disband group and restore visibility for all
                                ungroupPlanes();
                                planes.forEach(p => p.mesh.visible = true);
                            }
                        }
                    } else {
                        // Regular click - single selection
                        // Check if this plane is already the only selected plane
                        if (selectedPlanes.length === 1 && selectedPlanes[0] === planeData) {
                            // If clicking on the only selected plane, deselect it
                            selectedPlanes = [];
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);
                            ungroupPlanes();
                        } else {
                            // Otherwise, select this plane as the only selection
                            ungroupPlanes();
                            planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                            planes.forEach(p => p.mesh.visible = true);
                            selectedPlanes = [planeData];
                            planeData.mesh.material.color.setHex(0x808080);
                            updateTopViewLineColor(planeData, 0x808080);
                        }
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }
            }

            // Clicked on empty space without shift - clear selection
            if (!isShiftPressed) {
                ungroupPlanes();
                planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                selectedPlanes = [];
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
                removeNormalArrow(); // Remove arrow when nothing is selected
                
                // Reset sphere double-click tracking when clicking empty space
                lastClickedSphere = null;
                lastSphereClickTime = 0;
            }
        });

        function updateTransformControls() {
            if (selectedPlanes.length === 0) {
                // Only detach if transform controls are currently attached to something
                if (transformControlss.object) {
                    transformControlss.detach();
                }
                gui.destroy();
                gui = new dat.GUI();
                removeNormalArrow(); // Remove arrow when no planes selected
            } else if (selectedPlaneGroup) {
                // Control the group if we have one
                transformControlss.attach(selectedPlaneGroup);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            } else {
                // Control the last selected plane - ensure the mesh exists in scene (planes are in sceneContentGroup)
                const targetMesh = selectedPlanes[selectedPlanes.length - 1].mesh;
                if (targetMesh && targetMesh.parent) {
                    transformControlss.attach(targetMesh);
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                } else {
                    // If mesh doesn't exist or was removed, detach and clear selection
                    transformControlss.detach();
                    selectedPlanes = [];
                    gui.destroy();
                    gui = new dat.GUI();
                }
            }
            
            // Configure transform controls based on mode and view
            if (transformControlss.getMode() === 'rotate') {
                // Always disable Z rotation and show only X and Y
                transformControlss.showX = true;
                transformControlss.showY = true;
                transformControlss.showZ = false;
            } else if (activeCamera === cameras.top) {
                // In top view, disable Y scaling (thickness)
                transformControlss.showX = true;
                transformControlss.showY = false;
                transformControlss.showZ = true;
            } else {
                // Default: show all axes for translate and scale
                transformControlss.showX = true;
                transformControlss.showY = true;
                transformControlss.showZ = true;
            }

            // Always keep distance display up to date
            updateDistanceDisplay();
            // Update color scale inputs to reflect selected plane
            if (typeof updateColorScaleInputsForSelection === 'function') {
                updateColorScaleInputsForSelection();
            }
        }
        function createOrUpdateGroup() {
            // If no group exists, create one
            if (!selectedPlaneGroup) {
                selectedPlaneGroup = new THREE.Group();
                sceneContentGroup.add(selectedPlaneGroup);

                // Store original positions and parents
                originalPositions = new Map();
                selectedPlanes.forEach(plane => {
                    // Store the world position and original parent
                    const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                    originalPositions.set(plane, {
                        worldPosition: worldPos.clone(),
                        parent: plane.mesh.parent
                    });

                    // Calculate local position relative to group center
                    const center = calculateGroupCenter();
                    plane.mesh.position.copy(worldPos).sub(center);

                    // Add to group
                    selectedPlaneGroup.add(plane.mesh);
                });

                // Position group at center
                const center = calculateGroupCenter();
                selectedPlaneGroup.position.copy(center);
            } else {
                // For existing group, just add any new planes
                selectedPlanes.forEach(plane => {
                    if (plane.mesh.parent !== selectedPlaneGroup) {
                        const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                        originalPositions.set(plane, {
                            worldPosition: worldPos.clone(),
                            parent: plane.mesh.parent
                        });

                        const center = selectedPlaneGroup.position;
                        plane.mesh.position.copy(worldPos).sub(center);
                        selectedPlaneGroup.add(plane.mesh);
                    }
                });
            }
            // Don't capture state when creating/updating groups - only capture when the group is actually transformed
        }

        function calculateGroupCenter() {
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(plane.mesh.getWorldPosition(new THREE.Vector3()));
                }
            });
            center.divideScalar(selectedPlanes.length);
            return center;
        }

        function ungroupPlanes() {
            if (!selectedPlaneGroup) return;

            // Restore planes to their original positions and parents
            selectedPlanes.forEach(plane => {
                const original = originalPositions.get(plane);
                if (original) {
                    // Remove from group first
                    selectedPlaneGroup.remove(plane.mesh);

                    // Add back to original parent (usually the scene)
                    original.parent.add(plane.mesh);

                    // Restore world position
                    plane.mesh.position.copy(original.worldPosition);

                    // Update plane data to match world position
                    plane.x = plane.mesh.position.x;
                    plane.y = plane.mesh.position.y;
                    plane.z = plane.mesh.position.z;
                }
            });

            // Clean up the group
            sceneContentGroup.remove(selectedPlaneGroup);
            selectedPlaneGroup = null;
            originalPositions.clear();

            // Update GUI to reflect changes
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
            // Don't capture state when ungrouping - the visual state doesn't change
        }


        // Dragging variables
        let isDragging = false;
        let activeAxis = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let state_control = false;
        const raycaster1 = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let transformControlss = null;

        // Initialize transform controls
        function initTransformControls() {
            transformControlss = new THREE.TransformControls(activeCamera, renderer.domElement);
            transformControlss.setSpace('local');
            transformControlss.setMode('translate');
            transformControlss.size = 0.5;
            transformControlss.setTranslationSnap(0.01);  // Snap translation to 0.1 units
            transformControlss.setRotationSnap(Math.PI / 180); // Snap rotation to 10 degrees
            transformControlss.setScaleSnap(0.1); // Snap scaling to 0.05 units (5% increments)

            transformControlss.showX = true;
            transformControlss.showY = true;
            transformControlss.showZ = true;
            scene.add(transformControlss);

            // Disable orbit controls when transforming
            transformControlss.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                // When dragging starts, record the group's start position
                if (event.value && selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    groupDragStartPosition = selectedPlaneGroup.position.clone();
                }
                // When dragging ends (event.value === false)
                if (!event.value) {
                    if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                        // Commit the group transformation to individual planes
                        commitGroupTransform();
                    } else {
                        // Capture state for individual plane transformations
                        captureState("Transform drag ended");
                    }
                }
            });

            transformControlss.addEventListener('objectChange', function () {
                // Apply grid snapping based on current transform mode
                applyGridSnapping();

                if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    // Update all planes when group moves
                    selectedPlanes.forEach(plane => {
                        plane.x = plane.mesh.position.x + selectedPlaneGroup.position.x;
                        plane.y = plane.mesh.position.y + selectedPlaneGroup.position.y;
                        plane.z = plane.mesh.position.z + selectedPlaneGroup.position.z;
                        
                        // Update top view line if in top view
                        if (activeCamera === cameras.top) {
                            updateTopViewLine(plane);
                        }
                    });
                } else if (selectedPlanes.length > 0 &&
                    transformControlss.object === selectedPlanes[selectedPlanes.length - 1].mesh) {
                    updatePlaneDataFromTransform();
                    
                    // Update top view line if in top view
                    if (activeCamera === cameras.top) {
                        const plane = selectedPlanes[selectedPlanes.length - 1];
                        // console.log(`[objectChange] Updating topViewLine for ${plane.name} at (${plane.x.toFixed(2)}, ${plane.y.toFixed(2)}, ${plane.z.toFixed(2)})`);
                        updateTopViewLine(plane);
                    }
                }
                if (selectedPlanes.length > 0) {
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                }

                // Always keep distance display up to date
                updateDistanceDisplay();
            });
        }

        // Grid snapping implementation
        function applyGridSnapping() {
            if (!transformControlss.object) return;

            const currentMode = transformControlss.getMode();
            const object = transformControlss.object;

            // Get world position for proper grid alignment
            const worldPosition = new THREE.Vector3();
            object.getWorldPosition(worldPosition);

            switch (currentMode) {
                case 'translate':
                    if (gridSnapConfig.translation.enabled) {
                        // Snap world position to grid
                        const snappedWorldPos = new THREE.Vector3(
                            snapToGrid(worldPosition.x, gridSnapConfig.translation.size),
                            snapToGrid(worldPosition.y, gridSnapConfig.translation.size),
                            snapToGrid(worldPosition.z, gridSnapConfig.translation.size)
                        );

                        // Convert back to local position if object has a parent
                        if (object.parent && object.parent !== scene) {
                            const localPosition = new THREE.Vector3();
                            localPosition.copy(snappedWorldPos);
                            object.parent.worldToLocal(localPosition);
                            object.position.copy(localPosition);
                        } else {
                            object.position.copy(snappedWorldPos);
                        }
                    }
                    break;

                case 'rotate':
                    if (gridSnapConfig.rotation.enabled) {
                        // Snap rotation to increments
                        object.rotation.x = snapRotation(object.rotation.x, gridSnapConfig.rotation.increment);
                        object.rotation.y = snapRotation(object.rotation.y, gridSnapConfig.rotation.increment);
                        object.rotation.z = snapRotation(object.rotation.z, gridSnapConfig.rotation.increment);
                    }
                    break;

                case 'scale':
                    if (gridSnapConfig.scale.enabled) {
                        // Snap scale to increments with minimum
                        object.scale.x = snapScale(object.scale.x, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                        object.scale.y = snapScale(object.scale.y, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                        object.scale.z = snapScale(object.scale.z, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                    }
                    break;
            }
        }

        function commitGroupTransform() {
            if (!selectedPlaneGroup || selectedPlanes.length === 0) return;

            // Calculate the total transformation
            const groupPosition = selectedPlaneGroup.position.clone();

            // Update each plane's world position
            selectedPlanes.forEach(plane => {
                // Calculate new world position
                const newWorldPos = new THREE.Vector3().addVectors(
                    plane.mesh.position,
                    groupPosition
                );

                // Update plane data
                plane.x = newWorldPos.x;
                plane.y = newWorldPos.y;
                plane.z = newWorldPos.z;

                // Update original positions (for future grouping)
                if (originalPositions.has(plane)) {
                    originalPositions.get(plane).worldPosition.copy(newWorldPos);
                }
            });

            // Reset group position to origin
            selectedPlaneGroup.position.set(0, 0, 0);

            // Update plane positions relative to the group (now at origin)
            selectedPlanes.forEach(plane => {
                plane.mesh.position.set(plane.x, plane.y, plane.z);
            });

            // Re-center the group
            updateGroupPosition();

            // Update top view lines if in top view
            if (activeCamera === cameras.top) {
                selectedPlanes.forEach(plane => {
                    updateTopViewLine(plane);
                });
            }

            // Only capture state if the group was actually moved
            if (groupDragStartPosition && !groupDragStartPosition.equals(groupPosition)) {
                captureState();
            }
            groupDragStartPosition = null;
        }

        function updateGroupPosition() {
            if (!selectedPlaneGroup || selectedPlanes.length < 2) return;

            // Calculate center point in world space
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                }
            });
            center.divideScalar(selectedPlanes.length);

            // Update group position
            selectedPlaneGroup.position.copy(center);

            // Update plane positions relative to group
            selectedPlanes.forEach(plane => {
                const worldPos = originalPositions.has(plane) ?
                    originalPositions.get(plane).worldPosition.clone() :
                    new THREE.Vector3(plane.x, plane.y, plane.z);

                plane.mesh.position.copy(worldPos).sub(center);
            });
        }

        function updatePlaneDataFromTransform() {
            if (selectedPlanes.length === 0) return;

            const planeData = selectedPlanes[selectedPlanes.length - 1];
            const mesh = planeData.mesh;

            // Update position from actual mesh position
            planeData.x = mesh.position.x;
            planeData.y = mesh.position.y;
            planeData.z = mesh.position.z;

            // Extract rotation from mesh quaternion (more accurate than Euler angles)
            const euler = new THREE.Euler();
            euler.setFromQuaternion(mesh.quaternion, 'YXZ'); // Y rotation first, then X, then Z
            
            // Convert to degrees and update
            planeData.angle = Math.abs(euler.y * (180 / Math.PI)) < 1e-10 ? 0 : euler.y * (180 / Math.PI);
            planeData.incline = Math.abs(euler.x * (180 / Math.PI)) < 1e-10 ? 0 : euler.x * (180 / Math.PI);

            // Handle scaling
            if (transformControlss.getMode() === 'scale') {
                planeData.width = planeData.defaultWidth * mesh.scale.x;
                planeData.height = planeData.defaultHeight * mesh.scale.y;
                
            }


            // Update the GUI to reflect changes
            updateGUI(planeData);
        }

        // Call this after setting up your scene
        initTransformControls();

        function restoration() {
            if (state_control) {
                controls.enabled = true;
                controls.update();
                state_control = false;
            }
        }
        window.addEventListener("mousedown", restoration);
        window.addEventListener('keydown', (event) => {
            if (isTypingInInput()) return;
            if (!transformControlss) return;

            switch (event.key.toLowerCase()) {
                case 'a': // Add new plane
                    const newPlane = createPlane();
                    updateGUI(newPlane);
                    selectedPlane = newPlane;
                    selectedPlanes = [newPlane]; // Update selectedPlanes array
                    transformControlss.attach(newPlane.mesh);
                    
                    // If in top view, create the top view line immediately
                    if (activeCamera === cameras.top) {
                        createTopViewLine(newPlane);
                    }
                    
                    break;
                case 'w': // Translate
                    transformControlss.setMode('translate');
                    transformControlss.showZ = true;
                    updateTransformButtonStates();
                    break;
                case 'e': // Scale
                    transformControlss.setMode('scale');
                    transformControlss.showZ = true;
                    updateTransformButtonStates();
                    break;
                case 'r': // Rotate
                    transformControlss.setMode('rotate');
                    // Always disable Z rotation and show only X and Y
                    transformControlss.showX = true;
                    transformControlss.showY = true;
                    transformControlss.showZ = false;
                    updateTransformButtonStates();
                    break;
                case 'q': // Toggle between local and world space
                    const qBtn = document.getElementById("transformQ");
                    if (transformControlss.space === 'local') {
                        transformControlss.setSpace('world');
                        if (qBtn) qBtn.textContent = 'World';
                    } else {
                        transformControlss.setSpace('local');
                        if (qBtn) qBtn.textContent = 'Local';
                    }
                    break;
                case 'g': // Toggle grid snapping
                    gridSnapConfig.translation.enabled = !gridSnapConfig.translation.enabled;
                    gridSnapConfig.rotation.enabled = !gridSnapConfig.rotation.enabled;
                    gridSnapConfig.scale.enabled = !gridSnapConfig.scale.enabled;
                    updateGridSnapButtonState();
                    break;
                case 't': // Top view
                    setView(cameras.top);
                    break;
                case ',': // Rotate top view left (when in top view)
                    if (activeCamera === cameras.top) {
                        topViewRotationAngle += 0.1;
                        sceneContentGroup.rotation.y = topViewRotationAngle;
                    }
                    break;
                case '.': // Rotate top view right (when in top view)
                    if (activeCamera === cameras.top) {
                        topViewRotationAngle -= 0.1;
                        sceneContentGroup.rotation.y = topViewRotationAngle;
                    }
                    break;
                case 'y': // Perspective view
                    setView(cameras.perspective);
                    break;
                case 'n': // Toggle normal arrow visualization
                    showNormalArrow = !showNormalArrow;
                    
                    if (showNormalArrow) {
                        // Re-visualize if a receiver plane is selected
                        if (selectedPlanes.length > 0 && selectedPlanes[selectedPlanes.length - 1].type === "Receiver") {
                            visualizeNormal(selectedPlanes[selectedPlanes.length - 1]);
                        }
                    } else {
                        removeNormalArrow();
                    }
                    break;
                case 's': // Stand plane on ground
                    if (selectedPlanes.length > 0) {
                        standPlaneOnGround();
                    } else {
                    }
                    break;
                case 'h': // Toggle grid visibility
                    toggleGridVisibility();
                    break;
                case 'escape': // Exit plane mode
                    if (planeMode) {
                        exitPlaneMode();
                    }
                    break;
            }
        });
        window.addEventListener("keydown", function (event) {
            if (isTypingInInput()) return;
            if (event.key === "Delete") {
                deleteplanefn();
            }
        })

        // Add plane button
        const addplanebtn = document.getElementById("addplane");
        addplanebtn.addEventListener("click", function () {
            const newPlane = createPlane();
            updateGUI(newPlane);
            selectedPlane = newPlane;
            selectedPlanes = [newPlane]; // Update selectedPlanes array
            transformControlss.attach(newPlane.mesh);
            
            // If in top view, create the top view line immediately
            if (activeCamera === cameras.top) {
                createTopViewLine(newPlane);
            }
        });

        // Transform control buttons
        const qBtn = document.getElementById("transformQ");
        qBtn.addEventListener("click", function() {
            if (!transformControlss) return;
            if (transformControlss.space === 'local') {
                transformControlss.setSpace('world');
                this.textContent = 'World';
            } else {
                transformControlss.setSpace('local');
                this.textContent = 'Local';
            }
            updateTransformButtonStates();
        });
        // Initialize Q button text based on initial space
        qBtn.textContent = transformControlss.space === 'local' ? 'Local' : 'World';

        document.getElementById("transformW").addEventListener("click", function() {
            if (!transformControlss) return;
            transformControlss.setMode('translate');
            transformControlss.showZ = true;
            updateTransformButtonStates();
        });

        document.getElementById("transformE").addEventListener("click", function() {
            if (!transformControlss) return;
            transformControlss.setMode('scale');
            transformControlss.showZ = true;
            updateTransformButtonStates();
        });

        document.getElementById("transformR").addEventListener("click", function() {
            if (!transformControlss) return;
            transformControlss.setMode('rotate');
            transformControlss.showX = true;
            transformControlss.showY = true;
            transformControlss.showZ = false;
            updateTransformButtonStates();
        });

        // Function to update button active states
        function updateTransformButtonStates() {
            if (!transformControlss) return;
            
            const mode = transformControlss.getMode();
            const buttons = {
                w: document.getElementById("transformW"),
                e: document.getElementById("transformE"),
                r: document.getElementById("transformR")
            };
            
            // Remove active class from all
            Object.values(buttons).forEach(btn => btn.classList.remove('active'));
            
            // Add active class to current mode
            if (mode === 'translate') buttons.w.classList.add('active');
            else if (mode === 'scale') buttons.e.classList.add('active');
            else if (mode === 'rotate') buttons.r.classList.add('active');
        }
        
        // Initialize button states (default is translate mode)
        updateTransformButtonStates();

        // ===== PLANE CREATION FUNCTIONS =====
        
        // Function to start plane creation mode
        function startPlaneMode() {
            
            // Switch to top view
            setView(cameras.top);
            
            // Enable plane mode
            planeMode = true;
            planePoints = [];
            continuousPlanes = [];
            
            // Add click handler for ground plane
            planeClickHandler = (event) => {
                if (!planeMode) return;
                
                // Clear any existing timeout
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                    return; // This was a double-click, don't process as single click
                }
                
                // Set timeout to detect if this is a single click
                clickTimeout = setTimeout(() => {
                    
                    // Get mouse position
                    const mouse = new THREE.Vector2();
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    // Create raycaster
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, cameras.top);
                    
                    // Intersect with ground plane (Y=0)
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const intersectionPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
                    
                    if (intersectionPoint) {
                        addPlanePoint(intersectionPoint);
                    }
                    
                    clickTimeout = null;
                }, 200); // 200ms delay to detect double-click
            };
            
            // Add event listener with a small delay to prevent the button click from being registered
            setTimeout(() => {
                document.addEventListener('click', planeClickHandler);
            }, 100);
            
            // Update UI - disable the Add Plane Mode button while active
            const addPlaneBtn = document.getElementById('addPlaneMode');
            addPlaneBtn.disabled = true;
            addPlaneBtn.textContent = 'Adding walls';
            addPlaneBtn.style.background = '#dc3545';
            
        }
        
        // Function to add a plane point and create plane between consecutive points
        function addPlanePoint(point) {
            
            // Add point to array
            planePoints.push(point.clone());
            
            
            // Create plane if we have at least 2 points
            if (planePoints.length >= 2) {
                createContinuousPlane(planePoints[planePoints.length - 2], planePoints[planePoints.length - 1]);
            }
        }
        
        // Function to create a plane between two points using existing createPlane function
        function createContinuousPlane(point1, point2) {
            // Calculate plane properties
            const direction = new THREE.Vector3().subVectors(point2, point1);
            const length = direction.length();
            const center = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            
            // Create a plane using the existing createPlane function with calculated width
            // Skip state capture here - we'll do it in batch when exiting plane mode
            const continuousPlane = createPlane(length, 1, true); // Use calculated length as width, standard height of 1, skip state capture
            
            // Position the plane at the center point
            continuousPlane.mesh.position.set(center.x, 0.5, center.z);
            continuousPlane.x = center.x;
            continuousPlane.y = 0.5;
            continuousPlane.z = center.z;
            
            // Calculate rotation angle to align with the two points
            const angle = Math.atan2(direction.x, direction.z) - Math.PI / 2;
            continuousPlane.mesh.rotation.y = angle;
            continuousPlane.angle = angle * (180 / Math.PI);
            
            // Generate unique name similar to normal planes
            const planeNumber = planes.length;
            let baseName = `Plane ${planeNumber}`;
            let counter = 0;
            
            // Check for duplicate names and increment until we find a unique one
            while (planes.some(p => p.name === baseName)) {
                counter++;
                baseName = `Plane ${planeNumber + counter}`;
            }
            
            continuousPlane.name = baseName;
            
            // Note: createPlane() already adds the plane to the planes array, so no need to push again
            
            // Capture state after each plane is created for undo support
            captureState("Wall created");
            
            // Create top view line since we're in top view
            createTopViewLine(continuousPlane);
            
            // Verify and ensure spheres have proper userData properties for selection
            if (continuousPlane.mesh.userData.topViewSpheres) {
                const spheres = continuousPlane.mesh.userData.topViewSpheres;
                
                spheres.forEach((sphere, index) => {
                    // Ensure all required userData properties are set
                    sphere.userData.isSelectable = true;
                    sphere.userData.parentPlane = continuousPlane;
                    sphere.userData.sphereIndex = index;
                });
            }
        }
        
        // Function to exit plane creation mode
        function exitPlaneMode() {
            // State is now captured after each plane creation, no need for batch capture
            
            // Disable plane mode
            planeMode = false;
            
            // Clear any pending click timeout
            if (clickTimeout) {
                clearTimeout(clickTimeout);
                clickTimeout = null;
            }
            
            // Remove click handler
            if (planeClickHandler) {
                document.removeEventListener('click', planeClickHandler);
                planeClickHandler = null;
            }
            
            // Update UI - re-enable the Add Plane Mode button
            const addPlaneBtn = document.getElementById('addPlaneMode');
            addPlaneBtn.disabled = false;
            addPlaneBtn.textContent = 'Add Walls';
            addPlaneBtn.style.background = '#00a19b';
            
        }
        
        
        // Function to handle double-click to exit plane mode
        function handleDoubleClick(event) {
            if (planeMode) {
                event.preventDefault();
                event.stopPropagation();
                exitPlaneMode();
            }
        }

        // Plane creation event listeners
        document.getElementById('addPlaneMode').addEventListener('click', startPlaneMode);
        
        // Double-click to exit plane mode
        document.addEventListener('dblclick', handleDoubleClick);
        
        // Right-click panning for plane mode
        renderer.domElement.addEventListener('mousedown', (event) => {
            // Only enable right-click panning in plane mode and top view
            if (planeMode && activeCamera === cameras.top && event.button === 2) {
                event.preventDefault();
                isPanningInPlaneMode = true;
                panStartPosition = { x: event.clientX, y: event.clientY };
                cameraStartPosition = { 
                    x: cameras.top.position.x, 
                    z: cameras.top.position.z 
                };
                renderer.domElement.style.cursor = 'grabbing';
            }
        });
        
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (isPanningInPlaneMode && planeMode) {
                // Calculate how much the mouse has moved
                const deltaX = event.clientX - panStartPosition.x;
                const deltaY = event.clientY - panStartPosition.y;
                
                // Convert pixel movement to world units (adjust sensitivity based on zoom level)
                const zoomLevel = cameras.top.zoom || 1;
                const panSpeed = 0.01 / zoomLevel;
                
                // Update camera position (in top view, X is horizontal, Z is vertical on screen)
                cameras.top.position.x = cameraStartPosition.x - deltaX * panSpeed;
                cameras.top.position.z = cameraStartPosition.z - deltaY * panSpeed;
                
                // Update the controls target to move with camera (keeps view centered)
                controls.target.x = cameras.top.position.x;
                controls.target.z = cameras.top.position.z;
                controls.update();
            }
        });
        
        renderer.domElement.addEventListener('mouseup', (event) => {
            if (event.button === 2 && isPanningInPlaneMode) {
                isPanningInPlaneMode = false;
                renderer.domElement.style.cursor = 'default';
            }
        });
        
        // Custom right-click 2D rotation for top view
        let isTopViewRotating = false;
        let topViewRotateStartX = 0;
        const renderbodyEl = document.getElementById('renderbody');

        function isClickOnCanvas(target) {
            return renderbodyEl && (target === renderer.domElement || renderbodyEl.contains(target));
        }

        document.addEventListener('mousedown', (event) => {
            if (event.button === 2 && isClickOnCanvas(event.target) && activeCamera === cameras.top && !planeMode) {
                isTopViewRotating = true;
                topViewRotateStartX = event.clientX;
                controls.enabled = false;
                event.preventDefault();
                event.stopPropagation();
            }
        }, { capture: true });

        document.addEventListener('contextmenu', (event) => {
            if (isClickOnCanvas(event.target) && (activeCamera === cameras.top || planeMode)) {
                event.preventDefault();
            }
        }, { capture: true });

        document.addEventListener('mousemove', (event) => {
            if (isTopViewRotating && activeCamera === cameras.top) {
                event.preventDefault();
                const deltaX = event.clientX - topViewRotateStartX;
                topViewRotateStartX = event.clientX;
                const sensitivity = 0.005;
                topViewRotationAngle += deltaX * sensitivity;
                sceneContentGroup.rotation.y = topViewRotationAngle;
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 2 && isTopViewRotating) {
                isTopViewRotating = false;
                controls.enabled = true;
            }
        });

        // Mouse move handler for sphere dragging
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (isDraggingSphere && activeCamera === cameras.top) {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, activeCamera);
                
                // Get intersection with ground plane (Y=0)
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
                
                if (intersectionPoint) {
                    updateSphereDrag(intersectionPoint);
                }
            }
        });

        // Mouse down handler for sphere dragging
        renderer.domElement.addEventListener('mousedown', (event) => {
            if (activeCamera === cameras.top && selectedSphere && !isDraggingSphere) {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, activeCamera);
                const intersects = raycaster.intersectObjects([selectedSphere]);
                
                if (intersects.length > 0) {
                    const mousePosition = new THREE.Vector3();
                    raycaster.ray.at(intersects[0].distance, mousePosition);
                    startSphereDrag(selectedSphere, mousePosition);
                }
            }
        });

        // Mouse up handler for sphere dragging
        renderer.domElement.addEventListener('mouseup', (event) => {
            if (isDraggingSphere) {
                endSphereDrag();
            }
        });

        // Re-enable OrbitControls when user clicks after sphere dragging
        renderer.domElement.addEventListener('mousedown', function(event) {
            if (orbitControlsDisabled) {
                // Re-enable OrbitControls when user clicks anywhere
                controls.enabled = true;
                orbitControlsDisabled = false;
            }
        });

        // Export function
        document.getElementById('exportBtn').addEventListener('click', exportScene);

        function exportScene() {
            // Export all levels from sessionScenes, plus current scene if not already saved
            const allScenes = getSavedScenes();
            const currentSceneData = getCurrentSceneData();
            
            // Check if current scene is already saved
            const currentSceneName = document.getElementById('sceneDropdown').value;
            const isCurrentSceneSaved = currentSceneName && allScenes[currentSceneName];
            
            // Check if we have any saved levels
            const hasSavedLevels = Object.keys(allScenes).length > 0;
            
            if (!hasSavedLevels && !isCurrentSceneSaved) {
                // No levels saved, export as single level (old format for compatibility)
                const blob = new Blob([JSON.stringify(currentSceneData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'Scene_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                return;
            }
            
            // Create export data with all levels
            const exportData = {
                version: '2.0', // New version to indicate multi-level support
                exportType: 'multiLevel',
                levels: {},
                currentLevel: currentSceneName || 'default'
            };
            
            // Add all saved levels
            Object.keys(allScenes).forEach(levelName => {
                exportData.levels[levelName] = allScenes[levelName];
            });
            
            // Add current scene if it's not already saved
            if (!isCurrentSceneSaved) {
                exportData.levels['current'] = {
                    data: currentSceneData,
                    timestamp: new Date().toISOString()
                };
            }

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'Scene_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import function
        // document.getElementById('importBtn').addEventListener('click', () => {
        //     document.getElementById('importFile').click();
        // });

        document.getElementById('importFile').addEventListener('change', importScene);

        function importScene(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    // Check if this is a multi-level export
                    if (importData.exportType === 'multiLevel' && importData.levels) {
                        loadMultiLevelData(importData);
                    } else {
                        // Handle old single-level format
                        loadSceneData(importData);
                    }
                } catch (error) {
                    console.error('Error parsing scene file:', error);
                    alert('Error loading scene file');
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function clearScene() {
            // Detach transform controls
            if (transformControlss.object) {
                transformControlss.detach();
            }
            
            // Clear all planes manually (don't rely on deleteplanefn which requires selection)
            while (planes.length > 0) {
                const planeData = planes[0];
                
                // Remove from scene
                if (planeData.mesh) {
                    sceneContentGroup.remove(planeData.mesh);
                    
                    // Remove top view line if exists
                    if (planeData.mesh.userData.topViewLine) {
                        sceneContentGroup.remove(planeData.mesh.userData.topViewLine);
                    }
                    
                    // Remove top view spheres if exist
                    if (planeData.mesh.userData.topViewSpheres) {
                        planeData.mesh.userData.topViewSpheres.forEach(sphere => {
                            sceneContentGroup.remove(sphere);
                        });
                    }
                    
                    // Dispose geometry and material
                    if (planeData.mesh.geometry) {
                        planeData.mesh.geometry.dispose();
                    }
                    if (planeData.mesh.material) {
                        planeData.mesh.material.dispose();
                    }
                }
                
                // Remove from planes array
                planes.splice(0, 1);
            }
            
            // Clear selections
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                sceneContentGroup.remove(selectedPlaneGroup);
                selectedPlaneGroup = null;
            }
            
            // Reset image plane
            imagePlane.visible = false;
            if (imagePlane.material.map) {
                imagePlane.material.map.dispose();
                imagePlane.material.map = null;
                imagePlane.material.needsUpdate = true;
            }
            
            // Reset scaling
            scalingDistance = 0;
            scalingdist = false;
            const scaleInput = document.getElementById('scaleDistanceInput');
            if (scaleInput) {
                scaleInput.value = '';
            }
        }

        async function loadMultiLevelData(importData) {
            // Clear existing sessionScenes
            sessionScenes = {};
            
            // Load all levels into sessionScenes
            Object.keys(importData.levels).forEach(levelName => {
                sessionScenes[levelName] = importData.levels[levelName];
            });
            
            // Update the dropdown to show all imported levels
            updateSceneDropdown();
            
            // Load the current level (or first level if currentLevel not specified)
            const currentLevel = importData.currentLevel || Object.keys(importData.levels)[0];
            if (currentLevel && importData.levels[currentLevel]) {
                await loadSceneData(importData.levels[currentLevel]);
                
                // Set the dropdown to the current level
                document.getElementById('sceneDropdown').value = currentLevel;
                updateSaveButtonState();
            }
            
            alert(`Imported ${Object.keys(importData.levels).length} levels successfully!`);
        }

        async function loadSceneData(sceneData) {
            // Handle both old format (direct scene data) and new format (level manager wrapped data)
            let actualSceneData = sceneData;
            if (sceneData.data && sceneData.timestamp) {
                // This is a level manager scene (wrapped format)
                actualSceneData = sceneData.data;
            }
            
            // Validate that we have valid scene data
            if (!actualSceneData || (!actualSceneData.planes && !actualSceneData.imagePlane)) {
                console.error('Invalid scene data structure');
                alert('Invalid scene file format');
                return;
            }
            
            // Clear existing scene using the proper clearScene function
            clearScene();

            // Load image plane
            if (actualSceneData.imagePlane && actualSceneData.imagePlane.texture) {
                await loadImageTexture(actualSceneData.imagePlane.texture);

                imagePlane.position.fromArray(actualSceneData.imagePlane.position);
                imagePlane.rotation.fromArray(actualSceneData.imagePlane.rotation);
                imagePlane.scale.fromArray(actualSceneData.imagePlane.scale);
                imagePlane.visible = actualSceneData.imagePlane.visible;

                // Update geometry
                imagePlane.geometry.dispose();
                imagePlane.geometry = new THREE.PlaneGeometry(
                    actualSceneData.imagePlane.geometry.width,
                    actualSceneData.imagePlane.geometry.height
                );
            }

            // Load planes
            if (actualSceneData.planes) {
                actualSceneData.planes.forEach(planeData => {
                const newPlane = createPlane(planeData.width, planeData.height);
                newPlane.name = planeData.name || `Plane ${planes.length}`;

                // Update the default dimensions to match the imported dimensions
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;

                // Set position and rotation
                newPlane.mesh.position.fromArray(planeData.position);
                newPlane.mesh.rotation.fromArray(planeData.rotation);

                // Handle scale properly - if scale is not 1,1,1, we need to adjust the actual dimensions
                if (planeData.scale && (planeData.scale[0] !== 1 || planeData.scale[1] !== 1)) {
                    // If there's a scale, apply it to the dimensions
                    newPlane.width = planeData.width * planeData.scale[0];
                    newPlane.height = planeData.height * planeData.scale[1];
                    // Reset scale to 1,1,1 since we've incorporated it into dimensions
                    newPlane.mesh.scale.set(1, 1, 1);
                } else {
                    // No scale or scale is 1,1,1, just use the imported dimensions
                    newPlane.width = planeData.width;
                    newPlane.height = planeData.height;
                    newPlane.mesh.scale.set(1, 1, 1);
                }

                // Update the mesh geometry to match the new dimensions
                newPlane.mesh.geometry.dispose();
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Set color and temperature
                newPlane.color = planeData.color;
                newPlane.mesh.material.color.setHex(planeData.color);
                if (planeData.temperature !== undefined) {
                    newPlane.temperature = planeData.temperature;
                }
                if (planeData.type !== undefined) {
                    newPlane.type = planeData.type;
                }
                if (planeData.positive !== undefined) {
                    newPlane.positive = planeData.positive;
                } else {
                    newPlane.positive = true; // Default to true for backward compatibility
                }
                // Update derived properties - use imported values if available, otherwise calculate from mesh
                if (planeData.x !== undefined) {
                    newPlane.x = planeData.x;
                } else {
                    newPlane.x = newPlane.mesh.position.x;
                }
                if (planeData.y !== undefined) {
                    newPlane.y = planeData.y;
                } else {
                    newPlane.y = newPlane.mesh.position.y;
                }
                if (planeData.z !== undefined) {
                    newPlane.z = planeData.z;
                } else {
                    newPlane.z = newPlane.mesh.position.z;
                }
                if (planeData.angle !== undefined) {
                    newPlane.angle = planeData.angle;
                } else {
                    newPlane.angle = newPlane.mesh.rotation.y * (180 / Math.PI);
                }
                if (planeData.incline !== undefined) {
                    newPlane.incline = planeData.incline;
                } else {
                    newPlane.incline = newPlane.mesh.rotation.x * (180 / Math.PI);
                }

                // Restore contour data for receiver planes
                if (planeData.type === "Receiver" && planeData.contourData) {
                    newPlane.contourData = planeData.contourData;
                    console.log(`Restored contour data for receiver plane "${newPlane.name}": ${planeData.contourData.values.length} values`);
                }
                // Restore per-plane custom color scale override
                if (planeData.colorScaleMin != null) newPlane.colorScaleMin = planeData.colorScaleMin;
                if (planeData.colorScaleMax != null) newPlane.colorScaleMax = planeData.colorScaleMax;

                updateGUI(newPlane);

                // Force a geometry update to ensure the mesh size matches the stored dimensions
                if (newPlane.mesh.geometry) {
                    newPlane.mesh.geometry.dispose();
                }
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Apply contour texture if contour data exists
                if (newPlane.type === "Receiver" && newPlane.contourData) {
                    applyContourTexture(newPlane);
                    console.log(`Applied contour texture to receiver plane "${newPlane.name}"`);
                }

                });
            }

            // Load scaling data
            if (actualSceneData.scalingFactor) {
                scalingDistance = actualSceneData.scalingFactor.measuredDistance;
                scalingdist = true;
                const scaleInput = document.getElementById('scaleDistanceInput');
                if (scaleInput) {
                    scaleInput.value = actualSceneData.scalingFactor.inputValue;
                }
            }

            // Validate and fix any scaling issues
            planes.forEach(plane => {
                // Ensure the mesh geometry matches the stored dimensions
                const expectedWidth = plane.width;
                const expectedHeight = plane.height;
                const actualWidth = plane.mesh.geometry.parameters.width;
                const actualHeight = plane.mesh.geometry.parameters.height;

                if (Math.abs(expectedWidth - actualWidth) > 0.001 || Math.abs(expectedHeight - actualHeight) > 0.001) {

                    // Recreate geometry with correct dimensions
                    plane.mesh.geometry.dispose();
                    plane.mesh.geometry = new THREE.PlaneGeometry(expectedWidth, expectedHeight);

                    // Reset scale to 1,1,1
                    plane.mesh.scale.set(1, 1, 1);
                }
            });

            // If in top view, create top view lines for all imported planes
            if (activeCamera === cameras.top) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }
        }

        async function loadImageTexture(imageUrl) {
            return new Promise((resolve, reject) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageUrl,
                    (texture) => {
                        imagePlane.material.map = texture;
                        imagePlane.material.needsUpdate = true;
                        imagePlane.visible = true;

                        // Update aspect ratio
                        const img = new Image();
                        img.onload = function () {
                            aspect = img.width / img.height;
                            resolve();
                        };
                        img.src = imageUrl;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading image:', error);
                        reject(error);
                    }
                );
            });
        }

        // ==================== SCENE MANAGER ====================
        // Scene Manager functionality - Session-based only (not persistent)
        let sessionScenes = {}; // Temporary storage that clears on page reload

        function getCurrentSceneData() {
            return {
                version: '1.0',
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.toArray(),
                    rotation: imagePlane.rotation.toArray(),
                    scale: imagePlane.scale.toArray(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    },
                    texture: imagePlane.material.map ? imagePlane.material.map.image.currentSrc : null
                },
                planes: planes.map(plane => ({
                    name: plane.name,
                    position: plane.mesh.position.toArray(),
                    rotation: plane.mesh.rotation.toArray(),
                    scale: [1, 1, 1],
                    width: plane.width,
                    height: plane.height,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline,
                    // Include contour data for receiver planes
                    contourData: plane.type === "Receiver" && plane.contourData ? plane.contourData : null,
                    // Per-plane custom color scale override
                    colorScaleMin: plane.colorScaleMin,
                    colorScaleMax: plane.colorScaleMax
                })),
                scalingFactor: scalingdist ? {
                    measuredDistance: scalingDistance,
                    inputValue: document.getElementById('scaleDistanceInput')?.value || ''
                } : null
            };
        }

        function getSavedScenes() {
            return sessionScenes;
        }

        function saveScenesToStorage(scenes) {
            sessionScenes = scenes;
        }

        function updateSceneDropdown() {
            const dropdown = document.getElementById('sceneDropdown');
            const scenes = getSavedScenes();
            
            // Clear existing options except the first one
            dropdown.innerHTML = '<option value="">Select a level...</option>';
            
            // Add saved scenes to dropdown
            Object.keys(scenes).sort().forEach(sceneName => {
                const option = document.createElement('option');
                option.value = sceneName;
                option.textContent = sceneName;
                dropdown.appendChild(option);
            });
            updateSaveButtonState();
        }

        function updateSaveButtonState() {
            const btn = document.getElementById('saveSceneBtn');
            const dropdown = document.getElementById('sceneDropdown');
            const sceneName = dropdown.value;
            const scenes = getSavedScenes();
            const isEditingSavedLevel = sceneName && scenes[sceneName];
            btn.textContent = isEditingSavedLevel ? 'Update Level' : 'Save Level';
        }

        // clearScene function is defined earlier (before loadSceneData)

        // Save current scene button
        document.getElementById('saveSceneBtn').addEventListener('click', () => {
            const dropdown = document.getElementById('sceneDropdown');
            const sceneName = dropdown.value;
            const scenes = getSavedScenes();
            if (sceneName && scenes[sceneName]) {
                updateCurrentLevel();
            } else {
                showLevelNameModal();
            }
        });

        document.getElementById('sceneDropdown').addEventListener('change', updateSaveButtonState);

        function updateCurrentLevel() {
            const dropdown = document.getElementById('sceneDropdown');
            const sceneName = dropdown.value;
            if (!sceneName) return;
            
            const wasInTopView = (activeCamera === cameras.top);
            if (wasInTopView) {
                removeAllTopViewElements();
            }
            
            const scenes = getSavedScenes();
            const sceneData = getCurrentSceneData();
            scenes[sceneName] = {
                data: sceneData,
                timestamp: new Date().toISOString()
            };
            saveScenesToStorage(scenes);
            updateSceneDropdown();
            document.getElementById('sceneDropdown').value = sceneName;
            
            if (wasInTopView) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }
            alert(`Level "${sceneName}" updated successfully!`);
        }

        // Level name modal functions
        function showLevelNameModal() {
            const modal = document.getElementById('levelNameModal');
            const input = document.getElementById('levelNameInput');
            modal.style.display = 'block';
            input.value = '';
            input.focus();
        }

        function hideLevelNameModal() {
            const modal = document.getElementById('levelNameModal');
            modal.style.display = 'none';
        }

        function confirmLevelName() {
            const sceneName = document.getElementById('levelNameInput').value.trim();
            
            if (!sceneName) {
                alert('Please enter a name for the scene');
                return;
            }
            
            // Check if we're in top view
            const wasInTopView = (activeCamera === cameras.top);
            
            // Remove all top view elements (spheres and lines) before saving
            // This ensures they don't get saved as part of the scene
            if (wasInTopView) {
                removeAllTopViewElements();
            }
            
            const scenes = getSavedScenes();
            const sceneData = getCurrentSceneData();
            
            // Check if scene name already exists
            if (scenes[sceneName]) {
                if (!confirm(`Scene "${sceneName}" already exists. Do you want to overwrite it?`)) {
                    // Recreate top view elements if we were in top view
                    if (wasInTopView) {
                        planes.forEach(plane => {
                            createTopViewLine(plane);
                        });
                    }
                    return;
                }
            }
            
            // Save the scene
            scenes[sceneName] = {
                data: sceneData,
                timestamp: new Date().toISOString()
            };
            
            saveScenesToStorage(scenes);
            updateSceneDropdown();
            
            // Select the saved scene in dropdown
            document.getElementById('sceneDropdown').value = sceneName;
            
            // Recreate top view elements if we're in top view
            if (wasInTopView) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }
            
            hideLevelNameModal();
            alert(`Scene "${sceneName}" saved successfully!`);
        }

        // Event listeners for level name modal
        document.getElementById('confirmLevelName').addEventListener('click', confirmLevelName);
        
        document.getElementById('cancelLevelName').addEventListener('click', hideLevelNameModal);
        
        document.getElementById('levelNameInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                confirmLevelName();
            } else if (event.key === 'Escape') {
                hideLevelNameModal();
            }
        });

        // Load scene button
        document.getElementById('loadSceneBtn').addEventListener('click', async () => {
            const sceneName = document.getElementById('sceneDropdown').value;
            
            if (!sceneName) {
                alert('Please select a scene to load');
                return;
            }
            
            const scenes = getSavedScenes();
            const savedScene = scenes[sceneName];
            
            if (!savedScene) {
                alert('Scene not found');
                return;
            }
            
            // Load the scene
            try {
                await loadSceneData(savedScene);
                document.getElementById('sceneDropdown').value = sceneName;
                updateSaveButtonState();
                alert(`Scene "${sceneName}" loaded successfully!`);
            } catch (error) {
                console.error('Error loading scene:', error);
                alert('Error loading scene');
            }
        });

        // Delete scene button
        document.getElementById('deleteSceneBtn').addEventListener('click', () => {
            const sceneName = document.getElementById('sceneDropdown').value;
            
            if (!sceneName) {
                alert('Please select a scene to delete');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete scene "${sceneName}"?`)) {
                return;
            }
            
            const scenes = getSavedScenes();
            delete scenes[sceneName];
            saveScenesToStorage(scenes);
            document.getElementById('sceneDropdown').value = '';
            updateSceneDropdown();
            
            alert(`Scene "${sceneName}" deleted successfully!`);
        });

        // New blank canvas button
        document.getElementById('newSceneBtn').addEventListener('click', () => {
            if (planes.length > 0 || imagePlane.visible) {
                if (!confirm('This will clear the current scene. Do you want to continue?')) {
                    return;
                }
            }
            
            clearScene();
            document.getElementById('sceneDropdown').value = '';
            updateSaveButtonState();
        });

        // Initialize scene dropdown on page load
        updateSceneDropdown();
        // ==================== END SCENE MANAGER ====================

        let dataarrayforcontour = null;
        // Receiver grid size (N x N), default 2 (Low)
        let receiverGridSize = 2;
        // Backend endpoint for contour generation
        const BACKEND_CONTOUR_URL = CONFIG.BACKEND_URL + CONFIG.CALCULATE_ENDPOINT;
        
        // Calculation abort and progress (stop button + pseudo progress bar)
        let calculationAbortController = null;
        let calculationProgressInterval = null;
        
        // Approximate duration (ms) from total receiver points and resolution N. Based on test data.
        function estimateCalculationMs(totalPoints, N) {
            const n = Math.max(1, Math.min(10, parseInt(N, 10) || 2));
            let msPerPoint = 20;
            if (n <= 2) msPerPoint = 20;
            else if (n <= 3) msPerPoint = 27;
            else if (n <= 5) msPerPoint = 35;
            else msPerPoint = 9;
            return Math.max(300, Math.min(120000, totalPoints * msPerPoint));
        }

        /**
         * Count receiver-emitter point iterations.
         * Total = (sum of receiver points)  (sum of emitter points).
         * Example: 1 receiver 11 (x points), 2 emitters 11 each (y points each)  x  2y.
         * @param {Object} receiverPlaneData - { name: { width, height, points } }
         * @param {Array} emitterPlanes - planes with type "Emitter", each has width, height
         * @param {number} N - points per unit (grid resolution)
         * @returns {{ receiverPoints: number, emitterPoints: number, totalIterations: number, breakdown: Object }}
         */
        function countReceiverEmitterIterations(receiverPlaneData, emitterPlanes, N) {
            const n = Math.max(1, Math.min(10, parseInt(N, 10) || 2));
            let receiverPoints = 0;
            const receiverBreakdown = {};
            Object.keys(receiverPlaneData).forEach(name => {
                const p = receiverPlaneData[name];
                const pts = (p.width || 0) * (p.height || 0);
                receiverBreakdown[name] = pts;
                receiverPoints += pts;
            });

            let emitterPoints = 0;
            const emitterBreakdown = {};
            emitterPlanes.forEach(plane => {
                const gw = Math.max(2, Math.round((plane.width || 1) * n));
                const gh = Math.max(2, Math.round((plane.height || 1) * n));
                const pts = gw * gh;
                emitterBreakdown[plane.name || 'Unknown'] = pts;
                emitterPoints += pts;
            });

            return {
                receiverPoints,
                emitterPoints,
                totalIterations: receiverPoints * emitterPoints,
                breakdown: { receiver: receiverBreakdown, emitter: emitterBreakdown }
            };
        }
        
        // Color scale settings
        let colorScaleMin = 0;
        let colorScaleMax = 20;
        // Mode: 'manual' | 'perPlane' | 'global'
        // manual = use input values for all; perPlane = each plane's own range; global = overall range for all
        let colorScaleMode = 'manual';
        
        // Function to get color scale values from UI inputs
        function getColorScaleValues() {
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');
            
            const min = parseFloat(minInput.value) || 0;
            const max = parseFloat(maxInput.value) || 20;
            
            // Ensure max > min
            if (max <= min) {
                console.warn('Max value must be greater than min value. Using defaults.');
                return { min: 0, max: 20 };
            }
            
            return { min, max };
        }
        
        // Get overall min/max from all receiver planes with contour data
        function getOverallColorScaleRange() {
            const receiverPlanes = planes.filter(p => p.type === "Receiver" && p.contourData && p.contourData.values);
            if (receiverPlanes.length === 0) return { min: 0, max: 20 };
            let globalMin = Infinity, globalMax = -Infinity;
            receiverPlanes.forEach(p => {
                const dMin = Math.min(...p.contourData.values);
                const dMax = Math.max(...p.contourData.values);
                if (dMin < globalMin) globalMin = dMin;
                if (dMax > globalMax) globalMax = dMax;
            });
            if (globalMin === Infinity) return { min: 0, max: 20 };
            return { min: Math.floor(globalMin), max: Math.ceil(globalMax) };
        }
        
        // Get the effective color scale for a given plane (respects mode and per-plane custom override)
        function getColorScaleForPlane(plane) {
            if (!plane.contourData || !plane.contourData.values) return { min: 0, max: 20 };
            // Per-plane custom override (user typed min/max for selected plane)
            if (plane.colorScaleMin != null && plane.colorScaleMax != null &&
                typeof plane.colorScaleMin === 'number' && typeof plane.colorScaleMax === 'number' &&
                plane.colorScaleMax > plane.colorScaleMin) {
                return { min: plane.colorScaleMin, max: plane.colorScaleMax };
            }
            if (colorScaleMode === 'perPlane') {
                const dMin = Math.min(...plane.contourData.values);
                const dMax = Math.max(...plane.contourData.values);
                return { min: Math.floor(dMin), max: Math.ceil(dMax) };
            }
            if (colorScaleMode === 'global') {
                return getOverallColorScaleRange();
            }
            // manual: use UI inputs
            return getColorScaleValues();
        }
        
        // Function to create color legend
        function createColorLegend(minValue, maxValue, numTicks = 11, dataMin = null, dataMax = null) {
            const legendGradient = document.getElementById('legendGradient');
            const legendLabels = document.getElementById('legendLabels');
            const colorLegendDiv = document.getElementById('colorLegend');
            
            // Create gradient using d3 color scale
            const colorScale = d3.scaleSequential(d3.interpolateTurbo).domain([minValue, maxValue]);
            
            // Create CSS gradient
            const numStops = 100;
            let gradientStops = [];
            for (let i = 0; i <= numStops; i++) {
                const value = minValue + (maxValue - minValue) * (i / numStops);
                const color = colorScale(value);
                const percentage = (i / numStops) * 100;
                gradientStops.push(`${color} ${percentage}%`);
            }
            
            // Apply gradient (bottom to top, reversed because we want high values at top)
            legendGradient.style.background = `linear-gradient(to top, ${gradientStops.join(', ')})`;
            
            // Create labels
            legendLabels.innerHTML = '';
            const step = (maxValue - minValue) / (numTicks - 1);
            
            for (let i = 0; i < numTicks; i++) {
                const value = maxValue - (i * step); // Reverse order (high to low)
                const label = document.createElement('div');
                label.textContent = value.toFixed(2);
                label.style.fontWeight = 'bold';
                legendLabels.appendChild(label);
            }
            
            // Add data range info if provided
            let existingInfo = colorLegendDiv.querySelector('.data-range-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            if (dataMin !== null && dataMax !== null) {
                const infoDiv = document.createElement('div');
                infoDiv.className = 'data-range-info';
                infoDiv.innerHTML = `
                    <strong>Actual Data Range:</strong>
                    Min: ${dataMin.toFixed(3)}<br>
                    Max: ${dataMax.toFixed(3)}
                    ${(dataMin < minValue || dataMax > maxValue) ? '<br><br><strong style="color: #d9534f;"> Data exceeds color scale!</strong>' : ''}
                `;
                colorLegendDiv.appendChild(infoDiv);
            }
        }

        // Generate smoother, more realistic fields for contours
        // Removed random generators; contours now rely on backend-provided data only

        // Holder for backend-provided contour data
        let uploadedContour = null; // { width, height, values }

        // Normalize various JSON formats into {width,height,values(flat array)}
        function normalizeContourJson(json) {
            // If already normalized
            if (json && Number.isInteger(json.width) && Number.isInteger(json.height) && Array.isArray(json.values)) {
                // If values are 2D, flatten
                if (Array.isArray(json.values[0])) {
                    const flat = [];
                    for (let y = 0; y < json.height; y++) {
                        for (let x = 0; x < json.width; x++) {
                            flat.push(json.values[y][x]);
                        }
                    }
                    return { width: json.width, height: json.height, values: flat };
                }
                return { width: json.width, height: json.height, values: json.values };
            }
            // If just a 2D array
            if (Array.isArray(json) && Array.isArray(json[0])) {
                const height = json.length;
                const width = json[0].length;
                const flat = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) flat.push(json[y][x]);
                }
                return { width, height, values: flat };
            }
            // If just flat array, require square-ish detection is not reliable; reject
            throw new Error('Unsupported contour JSON format. Expected {width,height,values}, 2D array, or flat array with dims.');
        }

        // Note: uploadedContour should be set by backend integration code before invoking contour rendering

        function generateRbfField(n, m, options = {}) {
            const numSources = options.numSources || 5;
            const amplitudeMin = options.amplitudeMin ?? 2;
            const amplitudeMax = options.amplitudeMax ?? 10;
            const diag = Math.sqrt(n * n + m * m);
            const sigmaMin = options.sigmaMin ?? diag * 0.10;
            const sigmaMax = options.sigmaMax ?? diag * 0.35;
            const gradientStrength = options.gradientStrength ?? 0.15; // 0..1 small trend
            const noiseStd = options.noiseStd ?? 0.03; // relative to max amplitude

            const sources = [];
            for (let i = 0; i < numSources; i++) {
                sources.push({
                    cx: Math.random() * (n - 1),
                    cy: Math.random() * (m - 1),
                    amp: amplitudeMin + Math.random() * (amplitudeMax - amplitudeMin),
                    sigma: sigmaMin + Math.random() * (sigmaMax - sigmaMin)
                });
            }

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = 0;
                    for (let k = 0; k < sources.length; k++) {
                        const dx = x - sources[k].cx;
                        const dy = y - sources[k].cy;
                        const r2 = dx * dx + dy * dy;
                        const sigma2 = 2 * sources[k].sigma * sources[k].sigma;
                        v += sources[k].amp * Math.exp(-r2 / sigma2);
                    }
                    // Add a gentle gradient/trend to avoid overly symmetric blobs
                    v += gradientStrength * (x / n * amplitudeMax * 0.5 + y / m * amplitudeMax * 0.5);
                    // Add a tiny amount of noise for texture
                    v += (Math.random() * 2 - 1) * noiseStd * amplitudeMax;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            // Normalize to a friendly range (e.g., 0..10)
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generateSinusoidalField(n, m, options = {}) {
            const A1 = options.A1 ?? 3, A2 = options.A2 ?? 2.5, A3 = options.A3 ?? 2;
            const fx1 = options.fx1 ?? (2 * Math.PI / (n * 0.9));
            const fy1 = options.fy1 ?? (2 * Math.PI / (m * 0.7));
            const fx2 = options.fx2 ?? (2 * Math.PI / (n * 0.35));
            const fy2 = options.fy2 ?? (2 * Math.PI / (m * 0.5));
            const p1 = options.p1 ?? Math.random() * Math.PI * 2;
            const p2 = options.p2 ?? Math.random() * Math.PI * 2;
            const p3 = options.p3 ?? Math.random() * Math.PI * 2;
            const baseline = options.baseline ?? 2.5;
            const noiseStd = options.noiseStd ?? 0.05;

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = baseline
                        + A1 * Math.sin(fx1 * x + p1)
                        + A2 * Math.cos(fy1 * y + p2)
                        + A3 * Math.sin(fx2 * x + fy2 * y + p3)
                        + (Math.random() * 2 - 1) * noiseStd;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generatePointsOnPlane(plane, rows = 11, cols = 11) {
            
            const points = [];
            const width = plane.width;
            const height = plane.height;

            // Calculate step sizes
            const xStep = width / (cols - 1);
            const yStep = height / (rows - 1);

            // Get the plane's world position and rotation
            const worldPosition = plane.mesh.position.clone();
            const worldQuaternion = plane.mesh.quaternion.clone();

            // Generate grid points using the SAME coordinate system as computeWorldCorners()
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate local position (centered on plane)
                    // THREE.js PlaneGeometry lies in the XY plane with Z as the normal
                    const xLocal = (col * xStep) - (width / 2);
                    const yLocal = (row * yStep) - (height / 2);
                    const zLocal = 0; // On the plane surface (Z is perpendicular to plane)

                    // Create vector in local space
                    const point = new THREE.Vector3(xLocal, yLocal, zLocal);
                    
                    // Apply the mesh's rotation to transform from local to world space
                    point.applyQuaternion(worldQuaternion);
                    
                    // Add plane position offset
                    point.add(worldPosition);

                    points.push({
                        id: row * cols + col + 1,
                        position: {
                            x: parseFloat(point.x.toFixed(4)),
                            y: parseFloat(point.y.toFixed(4)),
                            z: parseFloat(point.z.toFixed(4))
                        },
                        localGrid: {
                            row: row + 1,
                            column: col + 1
                        }
                    });
                }
            }


            return points;
        }

        async function Pointsinfo() {
            const calculateBtn = document.getElementById('calculate');
            const originalText = 'Calculate';
            
            // If already calculating, treat click as Stop
            if (calculationAbortController) {
                calculationAbortController.abort();
                return;
            }
            
            const calcStartTime = Date.now();
            calculateBtn.textContent = 'Stop';
            calculateBtn.classList.add('calculating');
            calculateBtn.disabled = false;
            
            try {
                const receiver_planes = {};
                const polygons = [];
                const inert_polygons = [];

                // Helpers - Fixed to use actual mesh transformations
                function computeWorldCorners(plane) {
                    console.log(` Computing world corners for plane "${plane.name}"`);
                    console.log(`  Plane dimensions: ${plane.width} x ${plane.height}`);
                    console.log(`  Plane position: [${plane.x}, ${plane.y}, ${plane.z}]`);
                    console.log(`  Plane rotation (angle/incline): [${plane.angle}, ${plane.incline}]`);
                    
                    // Use the SAME coordinate system as standPlaneOnGround() and generatePointsOnPlane()
                    // THREE.js PlaneGeometry lies in the XY plane with Z as the normal
                    const halfWidth = plane.width / 2;
                    const halfHeight = plane.height / 2;
                    
                    const corners = [
                        new THREE.Vector3(-halfWidth, -halfHeight, 0),
                        new THREE.Vector3(halfWidth, -halfHeight, 0),
                        new THREE.Vector3(halfWidth, halfHeight, 0),
                        new THREE.Vector3(-halfWidth, halfHeight, 0)
                    ];
                    
                    console.log(`  Local corners before transform:`, corners.map(c => `[${c.x}, ${c.y}, ${c.z}]`));
                    
                    // Transform corners to world space using the ACTUAL mesh transformations
                    const worldCorners = corners.map(corner => {
                        const worldCorner = corner.clone();
                        
                        // Apply the mesh's actual quaternion rotation
                        worldCorner.applyQuaternion(plane.mesh.quaternion);
                        
                        // Add the mesh's actual world position
                        worldCorner.add(plane.mesh.position);
                        
                        return [
                            Math.round(worldCorner.x * 100) / 100,
                            Math.round(worldCorner.y * 100) / 100,
                            Math.round(worldCorner.z * 100) / 100
                        ];
                    });
                    
                    console.log(`  World corners after transform:`, worldCorners.map(c => `[${c[0]}, ${c[1]}, ${c[2]}]`));
                    
                    return worldCorners;
                }

                function computePlaneNormal(plane) {
                    // Get the plane's actual normal from its mesh orientation
                    // PlaneGeometry default normal is (0, 0, 1) in local space
                    const normal = new THREE.Vector3(0, 0, 1);
                    
                    // Apply the mesh's rotation to get the world-space normal
                    normal.applyQuaternion(plane.mesh.quaternion);
                    normal.normalize();
                    
                    console.log(`    Normal before positive/negative check: [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}], positive=${plane.positive}`);
                    
                    // Apply positive/negative setting
                    if (plane.positive) {
                        // If positive direction is desired, flip the normal
                        normal.negate();
                        console.log(`    Normal AFTER applying positive direction: [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}]`);
                    } else {
                        console.log(`    Normal kept as negative direction (no flip): [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}]`);
                    }
                    
                    // Return as array with high precision
                    return [
                        Math.round(normal.x * 10000) / 10000,
                        Math.round(normal.y * 10000) / 10000,
                        Math.round(normal.z * 10000) / 10000
                    ];
                }

                // Build structure
                // First, check for duplicate receiver plane names
                const receiverPlaneNames = new Set();
                const receiverPlanes = planes.filter(p => p.type === "Receiver");
                receiverPlanes.forEach(plane => {
                    if (receiverPlaneNames.has(plane.name)) {
                        alert(`Warning: Multiple receiver planes have the same name "${plane.name}". Please rename them to get accurate results.`);
                        console.error(` DUPLICATE NAME DETECTED: "${plane.name}"`);
                    }
                    receiverPlaneNames.add(plane.name);
                });
                
                console.log(`=== Processing ${receiverPlanes.length} Receiver Plane(s) ===`);
                
                // Collect receiver plane data by name first (order doesn't matter here)
                const receiverPlaneData = {};
                planes.forEach(plane => {
                    if (plane.type === "Receiver") {
                        // Calculate grid dimensions based on actual plane size and user input N
                        // N represents points per unit length, so we calculate grid points directly
                        const N = Math.max(1, Math.min(10, parseInt(receiverGridSize, 10) || 2));
                        
                        // Calculate grid dimensions using actual dimensions (not rounded)
                        // This ensures the grid perfectly covers the plane without black edges
                        const gridWidth = Math.max(2, Math.round(plane.width * N));
                        const gridHeight = Math.max(2, Math.round(plane.height * N));
                        
                        console.log(`\n Receiver plane "${plane.name}": size ${plane.width.toFixed(3)}x${plane.height.toFixed(3)}, grid size ${gridWidth}x${gridHeight} (${N} points/unit)`);
                        
                        const points = generatePointsOnPlane(plane, gridHeight, gridWidth);
                        const normalArr = computePlaneNormal(plane);
                        
                        console.log(`   Plane "${plane.name}" - angle: ${plane.angle}, incline: ${plane.incline}, positive: ${plane.positive}`);
                        console.log(`   Plane mesh position: [${plane.mesh.position.x.toFixed(2)}, ${plane.mesh.position.y.toFixed(2)}, ${plane.mesh.position.z.toFixed(2)}]`);
                        console.log(`   Plane mesh rotation (euler): [${(plane.mesh.rotation.x * 180/Math.PI).toFixed(2)}, ${(plane.mesh.rotation.y * 180/Math.PI).toFixed(2)}, ${(plane.mesh.rotation.z * 180/Math.PI).toFixed(2)}]`);
                        console.log(`    Computed normal: [${normalArr[0]}, ${normalArr[1]}, ${normalArr[2]}]`);
                        console.log(`   Sample point 0: [${points[0].position.x.toFixed(2)}, ${points[0].position.y.toFixed(2)}, ${points[0].position.z.toFixed(2)}]`);
                        console.log(`   Sample point ${points.length-1}: [${points[points.length-1].position.x.toFixed(2)}, ${points[points.length-1].position.y.toFixed(2)}, ${points[points.length-1].position.z.toFixed(2)}]`);
                        console.log(`   Total points generated: ${points.length}`);
                        
                        if (receiverPlaneData[plane.name]) {
                            console.error(` OVERWRITING existing receiver plane data for "${plane.name}"!`);
                        }
                        receiverPlaneData[plane.name] = {
                            width: gridWidth,
                            height: gridHeight,
                            points: points.map(pt => ({
                                origin: [
                                    Math.round(pt.position.x * 100) / 100,
                                    Math.round(pt.position.y * 100) / 100,
                                    Math.round(pt.position.z * 100) / 100
                                ],
                                normal: normalArr
                            }))
                        };
                    }
                });
                // Build receiver_planes in lexicographic order so backend (C++ std::map) iterates in same order as points
                Object.keys(receiverPlaneData).sort().forEach(name => {
                    receiver_planes[name] = receiverPlaneData[name];
                });
                
                planes.forEach(plane => {
                    if (plane.type === "Receiver") {
                        // already handled above
                    } else if (plane.type === "Emitter") {
                        const worldCorners = computeWorldCorners(plane);
                        console.log(`Emitter "${plane.name}" - temperature: ${plane.temperature}`);
                        console.log(`  Position: [${plane.x}, ${plane.y}, ${plane.z}]`);
                        console.log(`  Corners:`, worldCorners);
                        polygons.push({ polygon: worldCorners, temperature: plane.temperature });
                    } else if (plane.type === "Inert") {
                        const worldCorners = computeWorldCorners(plane);
                        inert_polygons.push(worldCorners);
                    }
                });

                const exportData = {
                    receiver_planes: receiver_planes,
                    polygons: polygons,
                    inert_polygons: inert_polygons,
                    num_rays: 100000
                };

                // Log the complete JSON output
                console.log("=== COMPLETE JSON OUTPUT ===");
                console.log(JSON.stringify(exportData, null, 2));
                console.log("=== END JSON OUTPUT ===");
                
                // Also log a summary
                console.log(`JSON Summary: ${Object.keys(receiver_planes).length} receiver planes, ${polygons.length} emitter polygons, ${inert_polygons.length} inert polygons`);

                // Count receiver-emitter iterations
                const emitterPlanes = planes.filter(p => p.type === "Emitter");
                const iterCount = countReceiverEmitterIterations(receiverPlaneData, emitterPlanes, receiverGridSize);
                console.log(`\n Iteration count: ${iterCount.receiverPoints} receiver points  ${iterCount.emitterPoints} emitter points = ${iterCount.totalIterations.toLocaleString()} total iterations`);
                console.log('   Receiver breakdown:', iterCount.breakdown.receiver);
                console.log('   Emitter breakdown:', iterCount.breakdown.emitter);

                // Pseudo progress: estimate time and animate bar
                const totalPoints = Object.values(receiverPlaneData).reduce((s, p) => s + p.width * p.height, 0);
                const estimatedMs = estimateCalculationMs(totalPoints, receiverGridSize);
                const progressWrap = document.getElementById('calcProgressWrap');
                const progressFill = document.getElementById('calcProgressFill');
                const progressPct = document.getElementById('calcProgressPct');
                progressWrap.classList.add('visible');
                progressFill.style.width = '0%';
                progressPct.textContent = '0%';
                
                calculationAbortController = new AbortController();
                const startTime = Date.now();
                calculationProgressInterval = setInterval(() => {
                    if (!calculationAbortController) return;
                    const elapsed = Date.now() - startTime;
                    const pct = Math.min(95, Math.round((elapsed / estimatedMs) * 95));
                    progressFill.style.width = pct + '%';
                    progressPct.textContent = pct + '%';
                }, 150);
                
                console.log('Sending data to backend:', exportData);
                const resp = await fetch(BACKEND_CONTOUR_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData),
                    signal: calculationAbortController.signal
                });
                
                if (!resp.ok) {
                    const errorText = await resp.text();
                    throw new Error(`Backend error: ${resp.status} - ${errorText}`);
                }
                
                clearInterval(calculationProgressInterval);
                calculationProgressInterval = null;
                progressFill.style.width = '100%';
                progressPct.textContent = '100%';
                
                const responseData = await resp.json();
                
                const calcElapsedMs = Date.now() - calcStartTime;
                console.log(`\n Calculation time: ${(calcElapsedMs / 1000).toFixed(2)}s (${calcElapsedMs}ms)  from Calculate click to backend data received`);
                
                // Log the complete backend response
                console.log('=== BACKEND RESPONSE RECEIVED ===');
                console.log('Full JSON response:', JSON.stringify(responseData, null, 2));
                console.log('Number of planes in response:', responseData.planes ? responseData.planes.length : 0);
                if (responseData.planes) {
                    responseData.planes.forEach((plane, idx) => {
                        console.log(`  Plane ${idx + 1}: "${plane.name}" - ${plane.width}x${plane.height} grid, ${plane.values.length} values`);
                        console.log(`    Temperature range: ${Math.min(...plane.values).toFixed(2)} to ${Math.max(...plane.values).toFixed(2)}`);
                    });
                }
                console.log('=== END BACKEND RESPONSE ===');
                
                if (responseData.success && responseData.planes && Array.isArray(responseData.planes)) {
                    // Process multiple planes
                    let planesProcessed = 0;
                    let planesNotMatched = [];
                    
                    console.log(`\n=== Matching Backend Response to Receiver Planes ===`);
                    console.log(`Backend returned ${responseData.planes.length} plane(s)`);
                    console.log(`We have ${receiverPlanes.length} receiver plane(s) in scene`);
                    
                    responseData.planes.forEach(planeData => {
                        console.log(`\n Looking for plane with name: "${planeData.name}"`);
                        
                        // Find matching receiver plane by name
                        const matchingPlane = planes.find(p => 
                            p.type === "Receiver" && p.name === planeData.name
                        );
                        
                        if (matchingPlane) {
                            // Store contour data on the plane object
                            matchingPlane.contourData = {
                                width: planeData.width,
                                height: planeData.height,
                                values: planeData.values
                            };
                            
                            console.log(` MATCHED! Contour data applied to receiver plane: ${matchingPlane.name}`);
                            console.log(`   Grid: ${planeData.width}x${planeData.height}, Values: ${planeData.values.length}`);
                            planesProcessed++;
                            
                            // Apply contour texture to the plane
                            applyContourTexture(matchingPlane);
                        } else {
                            console.error(` NO MATCH FOUND for backend plane: "${planeData.name}"`);
                            console.log(`   Available receiver planes: ${receiverPlanes.map(p => `"${p.name}"`).join(', ')}`);
                            planesNotMatched.push(planeData.name);
                        }
                    });
                    
                    console.log(`\n=== Matching Complete ===`);
                    console.log(` Successfully matched: ${planesProcessed}`);
                    console.log(` Not matched: ${planesNotMatched.length}`);
                    
                    if (planesNotMatched.length > 0) {
                        alert(`Calculation complete!\n\nMatched: ${planesProcessed} plane(s)\nNot matched: ${planesNotMatched.length} plane(s) (${planesNotMatched.join(', ')})\n\nCheck console for details.`);
                    } else {
                        alert(`Calculation complete! Contour data applied to ${planesProcessed} receiver plane(s).`);
                    }
                } else {
                    throw new Error('Invalid response format from backend');
                }
            } catch (err) {
                if (err.name === 'AbortError') {
                    console.log('Calculation stopped by user');
                } else {
                    console.error('Failed to fetch contour data:', err);
                    alert(`Failed to fetch contour data from backend: ${err.message}`);
                }
            } finally {
                if (calculationProgressInterval) {
                    clearInterval(calculationProgressInterval);
                    calculationProgressInterval = null;
                }
                calculationAbortController = null;
                const wrap = document.getElementById('calcProgressWrap');
                const fill = document.getElementById('calcProgressFill');
                const pctEl = document.getElementById('calcProgressPct');
                if (wrap) wrap.classList.remove('visible');
                if (fill) fill.style.width = '0%';
                if (pctEl) pctEl.textContent = '0%';
                calculateBtn.textContent = originalText;
                calculateBtn.classList.remove('calculating');
                calculateBtn.disabled = false;
            }
        }

        document.getElementById("calculate").addEventListener("click", Pointsinfo);
        
        // Update receiver grid size from dropdown
        const gridSizeEl = document.getElementById('gridSizeInput');
        if (gridSizeEl) {
            // Set initial value
            gridSizeEl.value = receiverGridSize.toString();
            
            gridSizeEl.addEventListener('change', function () {
                const val = parseInt(this.value, 10);
                if (isNaN(val)) return;
                receiverGridSize = val;
                console.log(`Precision changed to: ${this.options[this.selectedIndex].text} (${val})`);
            });
        }
        
        // Update color scale when inputs change and regenerate contours on existing data
        const colorScaleMinEl = document.getElementById('colorScaleMin');
        const colorScaleMaxEl = document.getElementById('colorScaleMax');
        
        function updateColorScale() {
            const { min, max } = getColorScaleValues();
            colorScaleMin = min;
            colorScaleMax = max;
            console.log(`Color scale updated: ${min} to ${max}`);
            
            // Regenerate contour textures for all planes that have contour data
            planes.forEach(plane => {
                if (plane.type === "Receiver" && plane.contourData) {
                    applyContourTexture(plane);
                }
            });
            
            // Show notification
            console.log('Contour colors updated for all receiver planes with data');
        }
        
        // Apply color scale from inputs to selected plane only (custom override)
        function updateColorScaleForSelectedPlane() {
            if (selectedPlanes.length === 0) return;
            const plane = selectedPlanes[0];
            if (plane.type !== "Receiver" || !plane.contourData) return;
            const { min, max } = getColorScaleValues();
            plane.colorScaleMin = min;
            plane.colorScaleMax = max;
            applyContourTexture(plane);
            console.log(`Custom color scale for ${plane.name}: ${min} to ${max}`);
        }
        
        // Update color scale inputs to reflect selected plane (custom values or data range)
        function updateColorScaleInputsForSelection() {
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');
            if (!minInput || !maxInput) return;
            if (selectedPlanes.length === 1 && selectedPlanes[0].type === "Receiver" && selectedPlanes[0].contourData) {
                const plane = selectedPlanes[0];
                if (plane.colorScaleMin != null && plane.colorScaleMax != null) {
                    minInput.value = plane.colorScaleMin;
                    maxInput.value = plane.colorScaleMax;
                } else {
                    const dMin = Math.min(...plane.contourData.values);
                    const dMax = Math.max(...plane.contourData.values);
                    minInput.value = Math.floor(dMin);
                    maxInput.value = Math.ceil(dMax);
                }
                minInput.disabled = false;
                maxInput.disabled = false;
            } else {
                // No plane selected or not a receiver with contour: show global range or defaults
                const range = getOverallColorScaleRange();
                minInput.value = range.min;
                maxInput.value = range.max;
                minInput.disabled = false;
                maxInput.disabled = false;
            }
        }
        
        if (colorScaleMinEl) {
            colorScaleMinEl.addEventListener('change', function() {
                if (selectedPlanes.length === 1 && selectedPlanes[0].type === "Receiver" && selectedPlanes[0].contourData) {
                    updateColorScaleForSelectedPlane();
                } else {
                    updateColorScale();
                }
            });
        }
        
        if (colorScaleMaxEl) {
            colorScaleMaxEl.addEventListener('change', function() {
                if (selectedPlanes.length === 1 && selectedPlanes[0].type === "Receiver" && selectedPlanes[0].contourData) {
                    updateColorScaleForSelectedPlane();
                } else {
                    updateColorScale();
                }
            });
        }

        // Auto color scale button handler - cycles: Auto -> Per Plane -> Global -> Per Plane -> Global -> ...
        const autoColorScaleBtn = document.getElementById('autoColorScaleBtn');
        if (autoColorScaleBtn) {
            autoColorScaleBtn.addEventListener('click', function() {
                // Cycle mode: manual -> perPlane -> global -> perPlane -> global -> ...
                if (colorScaleMode === 'manual') {
                    colorScaleMode = 'perPlane';
                    autoColorScaleBtn.textContent = 'Per Plane';
                } else if (colorScaleMode === 'perPlane') {
                    colorScaleMode = 'global';
                    autoColorScaleBtn.textContent = 'Global';
                } else {
                    colorScaleMode = 'perPlane';
                    autoColorScaleBtn.textContent = 'Per Plane';
                }
                
                // Re-apply contours to all receiver planes with data
                planes.forEach(plane => {
                    if (plane.type === "Receiver" && plane.contourData) {
                        applyContourTexture(plane);
                    }
                });
                
                console.log(`Color scale mode: ${colorScaleMode}`);
            });
        }

        // Add this function to handle the contour generation
        // Removed addContourToSelectedPlane; use backend-provided data via detail modal

        let clipboard = null; // Will store copied planes
        let isCtrlPressed = false; // Track Ctrl key state
        // Add these near your other key listeners
        window.addEventListener('keydown', (event) => {
            if (isTypingInInput()) return;
            if (event.key === 'Control') {
                isCtrlPressed = true;
            }
            // Add copy/paste shortcuts (Ctrl+C, Ctrl+V)
            if (isCtrlPressed && event.key === 'c') {
                copySelected();
            }
            if (isCtrlPressed && event.key === 'v') {
                pasteFromClipboard();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = false;
            }
        });

        function copySelected() {
            if (selectedPlanes.length === 0) return;

            clipboard = {
                isGroup: selectedPlaneGroup !== null,
                planes: selectedPlanes.map(plane => ({
                    width: plane.defaultWidth,
                    height: plane.defaultHeight,
                    position: plane.mesh.position.clone(),
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    positive: plane.positive
                })),
                relativePositions: selectedPlaneGroup ?
                    selectedPlanes.map(plane => plane.mesh.position.clone()) :
                    null
            };
            console.log('Copied selection to clipboard');
            captureState();
        }


        function pasteFromClipboard() {
            if (!clipboard) return;

            captureState("Before paste");

            // Clear current selection
            planes.forEach(p => p.mesh.material.color.setHex(p.color));
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // Create new planes from clipboard
            const newPlanes = [];
            const offset = new THREE.Vector3(1, 0, 1); // Small offset for pasted copies

            clipboard.planes.forEach((planeData, index) => {
                const newPlane = createPlane(planeData.width, planeData.height);

                // Set properties from copied plane
                newPlane.mesh.position.copy(planeData.position).add(offset);
                newPlane.mesh.rotation.copy(planeData.rotation);
                newPlane.mesh.scale.copy(planeData.scale);
                newPlane.mesh.material.color.setHex(planeData.color);

                // Update plane data with correct values
                newPlane.width = planeData.width * planeData.scale.x;
                newPlane.height = planeData.height * planeData.scale.y;
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;
                newPlane.x = newPlane.mesh.position.x;
                newPlane.y = newPlane.mesh.position.y;
                newPlane.z = newPlane.mesh.position.z;
                newPlane.angle = planeData.rotation.y * (180 / Math.PI);
                newPlane.incline = planeData.rotation.x * (180 / Math.PI);
                newPlane.color = planeData.color;
                newPlane.temperature = planeData.temperature;
                newPlane.type = planeData.type;
                newPlane.positive = planeData.positive !== undefined ? planeData.positive : true;

                // Select the new plane
                newPlanes.push(newPlane);
                newPlane.mesh.material.color.setHex(0x808080);
            });

            selectedPlanes = [...newPlanes];

            // If original was a group, recreate the group structure
            if (clipboard.isGroup && selectedPlanes.length > 1) {
                createOrUpdateGroup();

                // Apply relative positions if available
                if (clipboard.relativePositions) {
                    selectedPlanes.forEach((plane, index) => {
                        if (clipboard.relativePositions[index]) {
                            plane.mesh.position.copy(clipboard.relativePositions[index]);
                        }
                    });
                    updateGroupPosition();
                }
            }

            // If in top view, create top view lines for all pasted planes
            if (activeCamera === cameras.top) {
                newPlanes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }

            // Update transform controls and GUI
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                // Force GUI update with the correct values
                const lastPlane = selectedPlanes[selectedPlanes.length - 1];
                updateGUI(lastPlane);

                // Also update the mesh's userData to match
                lastPlane.mesh.userData = lastPlane;
            }

            console.log('Pasted from clipboard');
            captureState("After paste");
        }


        // Function to apply contour texture to a plane automatically
        function applyContourTexture(plane) {
            if (!plane.contourData || !plane.contourData.values) {
                console.warn(`No contour data for plane: ${plane.name}`);
                return;
            }
            
            console.log(`Applying contour texture to ${plane.name}`);
            
            const contourData = plane.contourData;
            const n = contourData.width;
            const m = contourData.height;
            
            // Get color scale for this plane (respects mode and per-plane custom override)
            const { min, max } = getColorScaleForPlane(plane);
            console.log(`Using color scale for ${plane.name}: ${min} to ${max}`);
            
            // Calculate SVG dimensions based on plane aspect ratio
            const planeAspectRatio = plane.width / plane.height;
            const planeArea = plane.width * plane.height;
            let baseSize = 512;
            if (planeArea > 25) {
                baseSize = Math.max(512, Math.round(Math.sqrt(planeArea) * 100));
            }
            
            let svgWidth, svgHeight;
            if (planeAspectRatio >= 1) {
                svgWidth = baseSize;
                svgHeight = Math.round(baseSize / planeAspectRatio);
            } else {
                svgHeight = baseSize;
                svgWidth = Math.round(baseSize * planeAspectRatio);
            }
            
            // Create SVG and generate contour
            const svg = d3.select("#contour-svg");
            svg.attr("width", svgWidth).attr("height", svgHeight);
            svg.selectAll("*").remove();
            
            const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                type: "Polygon",
                coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
            });
            
            const path = d3.geoPath().projection(projection);
            const contours = d3.contours().size([n, m]);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain([min, max]);
            
            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));
            
            // Convert SVG to Canvas
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');
            
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false;
                texture.flipY = false; // Flip texture vertically to match orientation
                
                // Mark as contour texture for state management
                // Store full contourData structure (width, height, values) for proper restoration
                texture.isContourTexture = true;
                texture.contourData = {
                    width: contourData.width,
                    height: contourData.height,
                    values: contourData.values
                };
                
                // Apply texture to plane
                plane.mesh.material.map = texture;
                plane.mesh.material.needsUpdate = true;
                plane.mesh.material.color.set(0xffffff); // Set to white so texture shows correctly
                
                console.log(` Contour texture applied to ${plane.name}`);
            };
            img.onerror = function(err) {
                console.error(`Failed to load contour image for ${plane.name}:`, err);
            };
            img.src = url;
        }

        function showContourToSelectedPlane() {
            if (selectedPlanes.length === 0) {
                alert("Please select a receiver plane first");
                return;
            }

            const selectedPlane = selectedPlanes[0]; // Use the first selected plane
            
            // Check if this is a receiver plane with contour data
            if (selectedPlane.type !== "Receiver") {
                alert("Please select a receiver plane. Only receiver planes have contour data.");
                return;
            }
            
            if (!selectedPlane.contourData || !selectedPlane.contourData.values) {
                alert(`No contour data available for ${selectedPlane.name}. Please run Calculate first.`);
                return;
            }
            
            // Log actual data range vs color scale range
            const dataMin = Math.min(...selectedPlane.contourData.values);
            const dataMax = Math.max(...selectedPlane.contourData.values);
            const { min: userScaleMin, max: userScaleMax } = getColorScaleForPlane(selectedPlane);
            
            console.log(` Contour Data Analysis for "${selectedPlane.name}":`);
            console.log(`   Actual data range: ${dataMin.toFixed(3)} to ${dataMax.toFixed(3)}`);
            console.log(`   Color scale range: ${userScaleMin} to ${userScaleMax}`);
            
            if (dataMin < userScaleMin || dataMax > userScaleMax) {
                console.warn(` Some data values are outside the color scale range!`);
                if (dataMin < userScaleMin) console.warn(`   ${(selectedPlane.contourData.values.filter(v => v < userScaleMin).length)} values below ${userScaleMin}`);
                if (dataMax > userScaleMax) console.warn(`   ${(selectedPlane.contourData.values.filter(v => v > userScaleMax).length)} values above ${userScaleMax}`);
            }

            // Get modal elements
            const modal = document.getElementById("contourModal");
            const modalImg = document.getElementById("contourImage");
            const valueDisplay = document.getElementById("valueDisplay");
            const span = document.getElementsByClassName("close")[0];

            // Use the selected plane's contour data
            const contourData = {
                width: selectedPlane.contourData.width,
                height: selectedPlane.contourData.height,
                values: selectedPlane.contourData.values
            };

            // Calculate SVG dimensions based on plane aspect ratio and size
            const planeAspectRatio = selectedPlane.width / selectedPlane.height;
            const planeArea = selectedPlane.width * selectedPlane.height;

            // Scale base size based on plane area to maintain texture quality
            // For larger planes, use higher resolution textures
            let baseSize = 512; // Minimum base size
            if (planeArea > 25) { // If plane area is larger than 5x5
                baseSize = Math.max(512, Math.round(Math.sqrt(planeArea) * 100)); // Scale with plane size
            }

            let svgWidth, svgHeight;

            if (planeAspectRatio >= 1) {
                // Plane is wider than tall
                svgWidth = baseSize;
                svgHeight = Math.round(baseSize / planeAspectRatio);
            } else {
                // Plane is taller than wide
                svgHeight = baseSize;
                svgWidth = Math.round(baseSize * planeAspectRatio);
            }

            // Update SVG dimensions
            const svg = d3.select("#contour-svg");
            svg.attr("width", svgWidth).attr("height", svgHeight);
            svg.selectAll("*").remove();

            const n = contourData.width;
            const m = contourData.height;

            // Use fitSize to properly scale the projection to the SVG dimensions
            const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                type: "Polygon",
                coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
            });

            const path = d3.geoPath().projection(projection);
            const contours = d3.contours().size([n, m]);
            
            // Get color scale for this plane (respects mode and per-plane custom override)
            const { min: colorMin, max: colorMax } = getColorScaleForPlane(selectedPlane);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain([colorMin, colorMax]);

            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));

            // Convert SVG to Canvas with matching dimensions
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');

            // Serialize SVG to string
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                // Set the image source and show the modal
                modalImg.src = canvas.toDataURL();
                modal.style.display = "block";
                
                // Show color legend with user-defined scale and actual data range
                const dataMin = Math.min(...contourData.values);
                const dataMax = Math.max(...contourData.values);
                createColorLegend(colorMin, colorMax, 11, dataMin, dataMax);

                // Create value map from original data
                const valueMap = [];
                for (let y = 0; y < m; y++) {
                    valueMap[y] = [];
                    for (let x = 0; x < n; x++) {
                        valueMap[y][x] = contourData.values[y * n + x];
                    }
                }

                // Zoom variables
                let scale = 1;
                const minScale = 0.5;
                const maxScale = 5;
                const zoomFactor = 0.1;

                // Mouse wheel zoom handler
                function handleWheel(e) {
                    e.preventDefault();

                    // Calculate new scale
                    if (e.deltaY < 0) {
                        scale = Math.min(scale + zoomFactor, maxScale);
                    } else {
                        scale = Math.max(scale - zoomFactor, minScale);
                    }

                    // Apply the scale with vertical flip
                    modalImg.style.transform = `scale(${scale}, ${-scale})`;
                    modalImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }

                // Mouse move handler to show values
                function handleMouseMove(e) {
                    const rect = modalImg.getBoundingClientRect();

                    // Calculate position relative to the image
                    const imgX = (e.clientX - rect.left) / rect.width;
                    const imgY = (e.clientY - rect.top) / rect.height;

                    if (imgX >= 0 && imgX <= 1 && imgY >= 0 && imgY <= 1) {
                        // Map to data coordinates (flip Y because image is flipped)
                        const dataX = Math.floor(imgX * n);
                        const dataY = Math.floor((1 - imgY) * m);

                        // Clamp to valid range
                        const x = Math.max(0, Math.min(n - 1, dataX));
                        const y = Math.max(0, Math.min(m - 1, dataY));

                        const value = valueMap[y][x];

                        // Position display above cursor when near bottom
                        const displayAbove = (e.clientY > window.innerHeight - 100);

                        valueDisplay.style.display = 'block';
                        valueDisplay.style.left = `${e.clientX + 15}px`;
                        valueDisplay.style.top = `${e.clientY + (displayAbove ? -40 : 15)}px`;
                        valueDisplay.textContent = `Value: ${value.toFixed(2)}`;
                    } else {
                        valueDisplay.style.display = 'none';
                    }
                }

                // Mouse leave handler
                function handleMouseLeave() {
                    valueDisplay.style.display = 'none';
                }

                // Add event listeners
                modalImg.addEventListener('wheel', handleWheel, { passive: false });
                modalImg.addEventListener('mousemove', handleMouseMove);
                modalImg.addEventListener('mouseleave', handleMouseLeave);

                // Cleanup function
                function cleanup() {
                    modalImg.removeEventListener('wheel', handleWheel);
                    modalImg.removeEventListener('mousemove', handleMouseMove);
                    modalImg.removeEventListener('mouseleave', handleMouseLeave);
                    modal.style.display = "none";
                    modalImg.style.transform = 'scaleY(-1)';
                    scale = 1; // Reset scale
                }

                // Close handlers
                span.onclick = cleanup;
                modal.onclick = function (e) {
                    if (e.target === modal) cleanup();
                };
                modalImg.onclick = function (e) {
                    e.stopPropagation();
                };
                
                // Prevent closing when clicking on color legend
                document.getElementById('colorLegend').onclick = function(e) {
                    e.stopPropagation();
                };
            };
            img.src = url;
        }

        // Add event listener to your contour button
        
        document.getElementById("detail").addEventListener("click", showContourToSelectedPlane);

        // ==================== DISTANCE CALCULATION ====================
        // Function to get all vertices of a plane mesh in world space
        function getPlaneVertices(plane) {
            const vertices = [];
            
            // Get the 4 corners of the plane in local space
            const halfWidth = plane.width / 2;
            const halfHeight = plane.height / 2;
            
            const localCorners = [
                new THREE.Vector3(-halfWidth, -halfHeight, 0),
                new THREE.Vector3(halfWidth, -halfHeight, 0),
                new THREE.Vector3(halfWidth, halfHeight, 0),
                new THREE.Vector3(-halfWidth, halfHeight, 0)
            ];
            
            // Transform to world space
            const worldPosition = new THREE.Vector3();
            const worldQuaternion = new THREE.Quaternion();
            plane.mesh.getWorldPosition(worldPosition);
            plane.mesh.getWorldQuaternion(worldQuaternion);
            
            localCorners.forEach(corner => {
                const worldCorner = corner.clone();
                worldCorner.applyQuaternion(worldQuaternion);
                worldCorner.add(worldPosition);
                vertices.push(worldCorner);
            });
            
            return vertices;
        }
        
        // Function to get plane geometry (center, normal, and bounds) in world space
        function getPlaneGeometry(plane) {
            const center = new THREE.Vector3();
            plane.mesh.getWorldPosition(center);
            
            const normal = new THREE.Vector3(0, 0, 1);
            normal.applyQuaternion(plane.mesh.quaternion);
            normal.normalize();
            
            const vertices = getPlaneVertices(plane);
            
            return {
                center: center,
                normal: normal,
                vertices: vertices
            };
        }
        
        // Function to calculate shortest distance from a point to a finite plane surface
        function pointToFinitePlaneDistance(point, planeGeo) {
            // Calculate signed distance from point to infinite plane
            const toPoint = new THREE.Vector3().subVectors(point, planeGeo.center);
            const signedDistance = toPoint.dot(planeGeo.normal);
            
            // Project point onto the infinite plane
            const projectedPoint = new THREE.Vector3().copy(point);
            projectedPoint.sub(planeGeo.normal.clone().multiplyScalar(signedDistance));
            
            // Check if projected point is within the plane's polygon bounds
            // Use point-in-polygon test on the plane surface
            const vertices = planeGeo.vertices;
            const isInside = isPointInPolygon(projectedPoint, vertices, planeGeo.normal);
            
            if (isInside) {
                // Point projects onto the plane surface, return perpendicular distance
                return Math.abs(signedDistance);
            } else {
                // Point projects outside plane bounds, find distance to nearest edge/corner
                let minDist = Infinity;
                
                // Check distance to all edges
                for (let i = 0; i < vertices.length; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % vertices.length];
                    const edgeDist = pointToLineSegmentDistance(point, v1, v2);
                    if (edgeDist < minDist) {
                        minDist = edgeDist;
                    }
                }
                
                return minDist;
            }
        }
        
        // Helper function to check if a point is inside a polygon (on the plane surface)
        function isPointInPolygon(point, vertices, normal) {
            // Project vertices and point onto a 2D plane perpendicular to normal
            // Find two axes perpendicular to normal
            const up = new THREE.Vector3(0, 1, 0);
            let u = new THREE.Vector3();
            if (Math.abs(normal.dot(up)) > 0.9) {
                u = new THREE.Vector3(1, 0, 0);
            } else {
                u.crossVectors(up, normal).normalize();
            }
            const v = new THREE.Vector3();
            v.crossVectors(normal, u).normalize();
            
            // Project all points to 2D
            const projected2D = vertices.map(vertex => {
                const rel = new THREE.Vector3().subVectors(vertex, vertices[0]);
                return {
                    x: rel.dot(u),
                    y: rel.dot(v)
                };
            });
            
            const pointRel = new THREE.Vector3().subVectors(point, vertices[0]);
            const point2D = {
                x: pointRel.dot(u),
                y: pointRel.dot(v)
            };
            
            // Ray casting algorithm for point-in-polygon
            let inside = false;
            for (let i = 0, j = projected2D.length - 1; i < projected2D.length; j = i++) {
                const xi = projected2D[i].x, yi = projected2D[i].y;
                const xj = projected2D[j].x, yj = projected2D[j].y;
                
                const intersect = ((yi > point2D.y) !== (yj > point2D.y)) &&
                    (point2D.x < (xj - xi) * (point2D.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        // Helper function to calculate distance from point to line segment
        function pointToLineSegmentDistance(point, lineStart, lineEnd) {
            const line = new THREE.Vector3().subVectors(lineEnd, lineStart);
            const lineLength = line.length();
            
            if (lineLength < 1e-10) {
                return point.distanceTo(lineStart);
            }
            
            const toPoint = new THREE.Vector3().subVectors(point, lineStart);
            const lineNormalized = line.clone().normalize();
            const t = Math.max(0, Math.min(lineLength, toPoint.dot(lineNormalized)));
            
            const closestPoint = new THREE.Vector3().copy(lineStart).add(lineNormalized.multiplyScalar(t));
            return point.distanceTo(closestPoint);
        }
        
        // Function to calculate shortest distance between two plane meshes
        // This calculates relative distance considering actual geometry
        function calculateShortestDistance(plane1, plane2) {
            // Get plane geometries in world space
            const geo1 = getPlaneGeometry(plane1);
            const geo2 = getPlaneGeometry(plane2);
            
            let minDistance = Infinity;
            
            // Check all vertices of plane1 against plane2's surface
            geo1.vertices.forEach(vertex => {
                const dist = pointToFinitePlaneDistance(vertex, geo2);
                if (dist < minDistance) {
                    minDistance = dist;
                }
            });
            
            // Check all vertices of plane2 against plane1's surface
            geo2.vertices.forEach(vertex => {
                const dist = pointToFinitePlaneDistance(vertex, geo1);
                if (dist < minDistance) {
                    minDistance = dist;
                }
            });
            
            // Also check edge-to-edge distances for parallel or nearly parallel planes
            const vertices1 = geo1.vertices;
            const vertices2 = geo2.vertices;
            
            // Check all edge combinations
            for (let i = 0; i < vertices1.length; i++) {
                const v1 = vertices1[i];
                const v1Next = vertices1[(i + 1) % vertices1.length];
                
                for (let j = 0; j < vertices2.length; j++) {
                    const v2 = vertices2[j];
                    const v2Next = vertices2[(j + 1) % vertices2.length];
                    
                    // Calculate shortest distance between two line segments
                    const edgeDist = lineSegmentToLineSegmentDistance(v1, v1Next, v2, v2Next);
                    if (edgeDist < minDistance) {
                        minDistance = edgeDist;
                    }
                }
            }
            
            return minDistance;
        }
        
        // Helper function to calculate shortest distance between two line segments
        function lineSegmentToLineSegmentDistance(p1, p2, p3, p4) {
            const d1 = p2.clone().sub(p1);
            const d2 = p4.clone().sub(p3);
            const r = p1.clone().sub(p3);
            
            const a = d1.dot(d1);
            const e = d2.dot(d2);
            const f = d2.dot(r);
            
            let s = 0;
            let t = 0;
            
            if (a < 1e-10 && e < 1e-10) {
                // Both segments are points
                return p1.distanceTo(p3);
            }
            
            if (a < 1e-10) {
                // First segment is a point
                s = 0;
                t = Math.max(0, Math.min(1, f / e));
            } else {
                const c = d1.dot(r);
                if (e < 1e-10) {
                    // Second segment is a point
                    t = 0;
                    s = Math.max(0, Math.min(1, -c / a));
                } else {
                    // Both segments are lines
                    const b = d1.dot(d2);
                    const denom = a * e - b * b;
                    
                    if (denom !== 0) {
                        s = Math.max(0, Math.min(1, (b * f - c * e) / denom));
                    } else {
                        s = 0;
                    }
                    
                    t = (b * s + f) / e;
                    if (t < 0) {
                        t = 0;
                        s = Math.max(0, Math.min(1, -c / a));
                    } else if (t > 1) {
                        t = 1;
                        s = Math.max(0, Math.min(1, (b - c) / a));
                    }
                }
            }
            
            const c1 = p1.clone().add(d1.clone().multiplyScalar(s));
            const c2 = p3.clone().add(d2.clone().multiplyScalar(t));
            
            return c1.distanceTo(c2);
        }
        
        // Function to update distance display
        function updateDistanceDisplay() {
            const distanceInput = document.getElementById('distanceInput');
            if (!distanceInput) return;
            
            if (selectedPlanes.length === 2) {
                const distance = calculateShortestDistance(selectedPlanes[0], selectedPlanes[1]);
                distanceInput.value = distance.toFixed(1);
            } else {
                distanceInput.value = '-';
            }
        }

        // Initialize distance display
        updateDistanceDisplay();
        // ==================== END DISTANCE CALCULATION ====================

        // Updated captureState function to handle all plane properties and new functionality
        function captureState(description = "User action") {
            // Don't capture during operations unless forced
            if (transformControlss && transformControlss.dragging) return;

            const state = {
                planes: planes.map(plane => ({
                    id: plane.id || generateId(), // Add unique IDs
                    position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(), // Store world position instead of local
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    width: plane.width,
                    height: plane.height,
                    // Store default values for reset functionality
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    defaultX: plane.defaultX,
                    defaultY: plane.defaultY,
                    defaultZ: plane.defaultZ,
                    defaultAngle: plane.defaultAngle,
                    defaultColor: plane.defaultColor,
                    // Store derived properties
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    name: plane.name,
                    selected: selectedPlanes.includes(plane),
                    // Store material properties including texture information
                    hasTexture: plane.mesh.material.map !== null,
                    textureData: plane.mesh.material.map ? {
                        isContourTexture: plane.mesh.material.map.isContourTexture || false,
                        contourData: plane.mesh.material.map.contourData || null
                    } : null,
                    // Per-plane custom color scale override
                    colorScaleMin: plane.colorScaleMin,
                    colorScaleMax: plane.colorScaleMax
                })),
                groups: selectedPlaneGroup ? {
                    planeIds: selectedPlanes.map(p => p.id),
                    position: selectedPlaneGroup.position.clone(),
                    rotation: selectedPlaneGroup.rotation.clone(),
                    scale: selectedPlaneGroup.scale.clone()
                } : null,
                // Store scene state
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.clone(),
                    rotation: imagePlane.rotation.clone(),
                    scale: imagePlane.scale.clone(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    }
                },
                // Store contour data if available
                contourData: dataarrayforcontour ? {
                    values: dataarrayforcontour,
                    timestamp: Date.now()
                } : null,
                description: description,
                timestamp: Date.now(),
                isPasteOperation: typeof description === 'string' && (description.includes("paste") || description.includes("Paste"))
            };

            // Trim history if needed
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Skip duplicate states
            if (history.length > 0) {
                const last = history[history.length - 1];
                if (JSON.stringify(last) === JSON.stringify(state)) return;
            }

            history.push(state);
            historyIndex = history.length - 1;

            // Limit history size
            if (history.length > MAX_HISTORY_STEPS) {
                history.shift();
                historyIndex--;
            }
        }


        // Remove duplicate event listener - this functionality is already handled in the main dragging-changed listener

        // Updated restoreState function to handle all plane properties and new functionality
        function restoreState(index) {
            if (index < 0 || index >= history.length) return;

            const state = history[index];
            console.log(`Restoring state: ${state.description || 'Unknown'}`);

            // Clear current selection and groups
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // First pass: update existing planes or create new ones
            const newPlanes = [];
            state.planes.forEach(planeState => {
                let plane = planes.find(p => p.id === planeState.id);

                if (!plane) {
                    // Create new plane
                    plane = createPlane(planeState.width, planeState.height);
                    plane.id = planeState.id;
                    console.log(`Created new plane with ID: ${planeState.id}`);
                } else {
                    console.log(`Found existing plane with ID: ${planeState.id}`);
                }

                // Ensure the plane is in the scene
                if (!sceneContentGroup.children.includes(plane.mesh) && (!selectedPlaneGroup || !selectedPlaneGroup.children.includes(plane.mesh))) {
                    sceneContentGroup.add(plane.mesh);
                }

                // For paste operations, ensure we're restoring to the exact state
                if (state.isPasteOperation) {
                    console.log(`Restoring paste operation state for plane ${planeState.id}`);
                }

                // Update all plane properties including defaults
                if (planeState.defaultWidth !== undefined) plane.defaultWidth = planeState.defaultWidth;
                if (planeState.defaultHeight !== undefined) plane.defaultHeight = planeState.defaultHeight;
                if (planeState.defaultX !== undefined) plane.defaultX = planeState.defaultX;
                if (planeState.defaultY !== undefined) plane.defaultY = planeState.defaultY;
                if (planeState.defaultZ !== undefined) plane.defaultZ = planeState.defaultZ;
                if (planeState.defaultAngle !== undefined) plane.defaultAngle = planeState.defaultAngle;
                if (planeState.defaultColor !== undefined) plane.defaultColor = planeState.defaultColor;

                // Update current properties
                plane.mesh.rotation.copy(planeState.rotation);
                plane.mesh.scale.copy(planeState.scale);
                plane.width = planeState.width;
                plane.height = planeState.height;
                plane.color = planeState.color;
                plane.temperature = planeState.temperature;
                plane.type = planeState.type;
                plane.name = planeState.name;
                plane.positive = planeState.positive !== undefined ? planeState.positive : true;
                plane.mesh.material.color.setHex(planeState.color);

                // Update derived properties
                plane.x = planeState.position.x;
                plane.y = planeState.position.y;
                plane.z = planeState.position.z;
                plane.angle = planeState.rotation.y * (180 / Math.PI);
                plane.incline = planeState.rotation.x * (180 / Math.PI);

                // Handle texture restoration if available
                if (planeState.hasTexture && planeState.textureData) {
                    if (planeState.textureData.isContourTexture && planeState.textureData.contourData) {
                        // Restore contour texture
                        restoreContourTexture(plane, planeState.textureData.contourData);
                    }
                }

                // Restore per-plane custom color scale override
                if (planeState.colorScaleMin != null) plane.colorScaleMin = planeState.colorScaleMin;
                if (planeState.colorScaleMax != null) plane.colorScaleMax = planeState.colorScaleMax;

                if (planeState.selected) {
                    selectedPlanes.push(plane);
                    plane.mesh.material.color.setHex(0x808080);
                } else {
                    plane.mesh.material.color.setHex(plane.color);
                }

                newPlanes.push(plane);
            });

            // Remove planes that shouldn't exist in this state
            const planesToRemove = planes.filter(p => !state.planes.some(s => s.id === p.id));
            planesToRemove.forEach(plane => {
                console.log(`Removing plane with ID: ${plane.id}`);
                
                // Remove top view line if it exists
                if (plane.mesh.userData.topViewLine) {
                    sceneContentGroup.remove(plane.mesh.userData.topViewLine);
                    plane.mesh.userData.topViewLine = null;
                }
                
                // Remove top view spheres if they exist
                if (plane.mesh.userData.topViewSpheres) {
                    plane.mesh.userData.topViewSpheres.forEach(sphere => {
                        sceneContentGroup.remove(sphere);
                    });
                    plane.mesh.userData.topViewSpheres = null;
                }
                
                if (plane.mesh.parent) {
                    plane.mesh.parent.remove(plane.mesh);
                }
                plane.mesh.geometry.dispose();
                plane.mesh.material.dispose();
            });

            // Update planes array
            planes.splice(0, planes.length, ...newPlanes);

            // Set positions for all planes first (before grouping)
            newPlanes.forEach(plane => {
                const planeState = state.planes.find(p => p.id === plane.id);
                if (planeState) {
                    plane.mesh.position.copy(planeState.position);
                    console.log(`Set plane ${plane.id} position to: ${planeState.position}`);
                }
            });
            
            // Recreate top view lines and spheres for all planes if in top view
            if (activeCamera === cameras.top) {
                newPlanes.forEach(plane => {
                    createTopViewLine(plane);
                });
                console.log(`[restoreState] Recreated topViewLines and spheres for ${newPlanes.length} planes`);
            }

            // Restore group if needed
            if (state.groups) {
                selectedPlanes = planes.filter(p => state.groups.planeIds.includes(p.id));

                // Create group without calling captureState (we'll do it manually)
                if (!selectedPlaneGroup) {
                    selectedPlaneGroup = new THREE.Group();
                    sceneContentGroup.add(selectedPlaneGroup);
                    originalPositions = new Map();
                }

                // Clear existing planes from group
                while (selectedPlaneGroup.children.length > 0) {
                    selectedPlaneGroup.remove(selectedPlaneGroup.children[0]);
                }

                // Add planes to group and store their original positions
                selectedPlanes.forEach(plane => {
                    const planeState = state.planes.find(p => p.id === plane.id);
                    if (planeState) {
                        // Store original world position
                        originalPositions.set(plane, {
                            worldPosition: planeState.position.clone(),
                            parent: scene
                        });

                        // Add to group (position is already set)
                        selectedPlaneGroup.add(plane.mesh);

                        console.log(`Added plane ${plane.id} to group with position: ${plane.mesh.position}`);
                    }
                });

                // Set group position
                selectedPlaneGroup.position.copy(state.groups.position);
                selectedPlaneGroup.rotation.copy(state.groups.rotation);
                selectedPlaneGroup.scale.copy(state.groups.scale);

                console.log(`Set group position to: ${state.groups.position}`);
            }

            // Restore image plane state if available
            if (state.imagePlane) {
                imagePlane.visible = state.imagePlane.visible;
                imagePlane.position.copy(state.imagePlane.position);
                imagePlane.rotation.copy(state.imagePlane.rotation);
                imagePlane.scale.copy(state.imagePlane.scale);

                // Update geometry if dimensions changed
                if (state.imagePlane.geometry) {
                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(
                        state.imagePlane.geometry.width,
                        state.imagePlane.geometry.height
                    );
                }
            }

            // Restore contour data if available
            if (state.contourData && state.contourData.values) {
                dataarrayforcontour = state.contourData.values;
                console.log(`Restored contour data with ${dataarrayforcontour.length} values`);
            }

            // Update GUI and controls
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

            // Update GUI
            gui.destroy();
            gui = new dat.GUI();

            // If in top view, create top view lines for all restored planes
            if (activeCamera === cameras.top) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }

            console.log(`State restoration complete. Total planes: ${planes.length}, Selected: ${selectedPlanes.length}`);
            console.log(`Current plane IDs: ${planes.map(p => p.id).join(', ')}`);
            console.log(`Selected plane IDs: ${selectedPlanes.map(p => p.id).join(', ')}`);

            // Debug: Log final positions of all planes
            planes.forEach(plane => {
                const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                console.log(`Final plane ${plane.id}: local=${plane.mesh.position}, world=${worldPos}`);
            });

            if (selectedPlaneGroup) {
                console.log(`Group position: ${selectedPlaneGroup.position}`);
                console.log(`Group children: ${selectedPlaneGroup.children.length}`);
            }
        }

        // Helper function to restore contour textures
        function restoreContourTexture(plane, contourData) {
            try {
                // Handle contourData which can be either:
                // 1. An object with {width, height, values}
                // 2. Just an array of values (legacy format)
                let gridWidth, gridHeight, values;
                
                if (contourData && typeof contourData === 'object' && contourData.width && contourData.height && contourData.values) {
                    // New format: object with width, height, values
                    gridWidth = contourData.width;
                    gridHeight = contourData.height;
                    values = contourData.values;
                } else if (plane.contourData && plane.contourData.width && plane.contourData.height) {
                    // Use stored dimensions from the plane's contourData
                    gridWidth = plane.contourData.width;
                    gridHeight = plane.contourData.height;
                    values = Array.isArray(contourData) ? contourData : plane.contourData.values;
                } else {
                    // Fallback: estimate from array length (legacy support)
                    values = Array.isArray(contourData) ? contourData : (contourData.values || contourData);
                    const totalPoints = values.length;
                    const aspectRatio = plane.width / plane.height;
                    gridHeight = Math.round(Math.sqrt(totalPoints / aspectRatio));
                    gridWidth = Math.round(gridHeight * aspectRatio);
                }

                // Calculate SVG dimensions based on plane aspect ratio
                const planeAspectRatio = plane.width / plane.height;
                let baseSize = 512;
                if (plane.width * plane.height > 25) {
                    baseSize = Math.max(512, Math.round(Math.sqrt(plane.width * plane.height) * 100));
                }

                let svgWidth, svgHeight;
                if (planeAspectRatio >= 1) {
                    svgWidth = baseSize;
                    svgHeight = Math.round(baseSize / planeAspectRatio);
                } else {
                    svgHeight = baseSize;
                    svgWidth = Math.round(baseSize * planeAspectRatio);
                }

                // Create SVG and generate contour
                const svg = d3.select("#contour-svg");
                svg.attr("width", svgWidth).attr("height", svgHeight);
                svg.selectAll("*").remove();

                const n = gridWidth;
                const m = gridHeight;

                const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                    type: "Polygon",
                    coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
                });

                const path = d3.geoPath().projection(projection);
                const contours = d3.contours().size([n, m]);
                
                // Ensure plane has contourData for getColorScaleForPlane
                plane.contourData = { width: gridWidth, height: gridHeight, values };
                // Get color scale for this plane (respects mode and per-plane custom override)
                const { min, max } = getColorScaleForPlane(plane);
                const color = d3.scaleSequential(d3.interpolateTurbo).domain([min, max]);

                svg.append("g")
                    .attr("stroke", "black")
                    .selectAll()
                    .data(color.ticks(20))
                    .join("path")
                    .attr("d", d => path(contours.contour(values, d)))
                    .attr("fill", d => color(d));

                // Convert SVG to texture
                const canvas = document.createElement('canvas');
                canvas.width = svgWidth;
                canvas.height = svgHeight;
                const ctx = canvas.getContext('2d');

                const svgString = new XMLSerializer().serializeToString(svg.node());
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = false;
                    texture.flipY = false; // Flip texture vertically to match orientation

                    // Mark as contour texture for future state captures
                    // Store full structure for proper restoration
                    texture.isContourTexture = true;
                    texture.contourData = {
                        width: gridWidth,
                        height: gridHeight,
                        values: values
                    };

                    plane.mesh.material.map = texture;
                    plane.mesh.material.needsUpdate = true;
                    plane.mesh.material.color.set(0xffffff);

                    console.log(`Restored contour texture for plane ${plane.id}`);
                };
                img.src = url;
            } catch (error) {
                console.error(`Error restoring contour texture for plane ${plane.id}:`, error);
            }
        }



        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (!isTopViewRotating) controls.update();
            renderer.render(scene, activeCamera);
            labelRenderer.render(scene, activeCamera);
        }
        animate();

        // Test backend connection when page loads
        testBackendConnection();

        // Handle window resize
        window.addEventListener("resize", () => {
            cameras.perspective.aspect = window.innerWidth / window.innerHeight;
            cameras.perspective.updateProjectionMatrix();
            activeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            updateOrthoCameras();

            // Update transform controls if they exist
            if (transformControlss) {
                transformControlss.camera = activeCamera;
            }
        });
    </script>
</body>

</html>
